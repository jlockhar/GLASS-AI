---
title: "GLASS-AI Analysis Summary Report"
subtitle: "Experiment Name"
author: "GLASS-AI ^[https://github.com/jlockhar/GLASS-AI]"
date: '`r format(Sys.time(), "%a %b %d %X %Y")`'
output:
  html_document:
    code_folding: hide
    df_print: kable
  html_notebook:
    code_folding: hide
    df_print: kable
editor_options:
  markdown:
    wrap: 80
script_updated: 08/15/23
---

# Description


##### Notes

- Add any notes about your analysis here.
- I strongly recommend using normalized measures, such as `proportion of tumors`, `proportion of total tumor area`, and `proportion of lung area` for your comparisons rather than `tumor counts` or `total tumor area`.
- Graphs in `No tumor grading` tabs use the raw pixel-level grading produced by GLASS-AI for the analysis. While `Graded tumors` tabs perform analysis using the overall tumor grade assigned to each tumor based on (in this experiment) the highest tumor grade present that comprises ≥ 10% of the tumors area. 
- Statistical tests are performed largely automatically in this report and are set up to use non-parametric methods if any significant violations of normality or homogeneity of variance are detected in the data. 
  - The parametric tests that this report uses are fairly robust to violations of these assumptions and can be selected manually if desired by setting 'useParametric = parametric_test_individuals' in `run_omnibus_test()` calls (will be propagated to post-hoc tests automatically).  
  - Statistical test results are provided in `Statistics Results` below the graph they apply to.
- All of the data to generate the graphs in this analysis are contained in `Whole slide summary.xslx` and the image summary files (e.g., `492586.xlsx`). For convenience, the subset of the data used to generate each graph is provided in the `Graph Data` folder should you wish to generate your own version of the plots.


#### Notable Results

- Add your notable results here.

--------------------------------------------------------------------------------

# Analysis Setup {.tabset .tabset-fade .tabset-pills}

```{r setup, include = FALSE}
chooseCRANmirror(graphics = FALSE, ind = 1)

## First specify the packages of interest
packages <- c(
  "tidyverse", # Data formating and manipulation
  "readxl", # read input xlsx files
  "knitr", # make tables
  "stringr", # easier string operations
  "janitor", # clean factor names in dataframes
  "ggrepel", # add labels outside of bars in plots
  "ggpubr", # format ggplot objects
  "ggpp", # more ggplot formatting
  "rstatix", # do statistics
  "plotly", # interact with ggplot objects
  "rlang", # error handling
  "moments" # calculate skewness and kurtosis for stats summaries
)
## Now load or install & load all
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

# Chunk options
knitr::opts_chunk$set(
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.8,
  out.width = "100%",
  results = "asis",
  message = FALSE,
  warning = FALSE,
  echo = FALSE
)
opts_knit$set(eval.after = "fig.cap")
options(knitr.table.format = "pipe")
```

```{css css_setup, echo=FALSE}
p.caption {
  font-size: 0.9em;
  font-style: italic;
  color: grey;
  margin-right: 5%;
  margin-left: 5%;  
  text-align: justify;
}

/* resize the widget container */
.plotly { 
  width: 100% !important;
}

/* center the widget */
div.svg-container {
  margin: auto !important;
}
```

```{r custom_functions, message = FALSE, warning = FALSE}
#' add formatted labels as new column in a dataframe using lists of variable names and labels
#' 
#' @description
#' Create a list of formatted labels and variables to include in plotly hoverinfo
#' 
#' @param xdf A dataframe that includes the columns named in `var_names`.
#' 
#' @param var_names A character vector of variable names to make labels for.
#' 
#' @param var_labels A character vector of formatted labels for each variable in `var_names`.
#' 
#' @param label_col_name A string for the name of the column added to `xdf` to store the formatted labels.
#' 
#' @returns Returns the input data frame with an additional column containing formatted labels (<b>var_label: </b> var_name </br>)
make_formatted_labels <- function(xdf, var_names, var_labels, label_col_name){
  xdf <- xdf %>% 
    rowwise() %>%
    mutate(!!label_col_name := paste0("<b>",
    var_labels,
    ": </b>",
    across(all_of(var_names)),
    "</br>",
    collapse = ""
  ))
  return(xdf)
}

#' Test normality of data with and without log normalization
#' 
#' @description
#' Performs a Shapiro-Wilk test of normality on data and a log normalized version of the data to determine if log normalization should be applied.
#' 
#' @param xdf A dataframe that includes the columns named in `xformula`.
#' 
#' @param xformula A formula defining the response and independent variables to be used in later analyses.
#' 
#' @param xbase The base to be used for log transformation (Default = 10)
#' 
#' @returns Returns `TRUE` if data should be log normalized and `FALSE` if it should not.
#' 
#' @noRd
test_log_normalization <- function(xdf, xformula, xbase = 10) {
  
    # validate input classes
  if (sum(class(xdf) == "dataframe") == 0) {
    errorCondition("Input provided for 'dataframe' was not a dataframe")
  }
  if (class(xformula) == "character") {
    xformula <- as.formula(xformula)
  }
  if (class(xformula) != "formula") {
    errorCondition("Input provided for 'formula' was not of class 'formula' or 'character'")
  }

  # get grouping variables from formula
  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]

  # remove any grouping from dataframe
  xdf <- xdf %>% ungroup()
  
  # test for normal distribution of data
  #-group data by independent variable(s) from formula
  norm_test <- NULL
  norm_violation <- NULL
  norm_violation_count <- 0
  tryCatch(
    {
      norm_test <- permissive_shapiro(xdf, xformula)
      norm_violation_count <- sum(norm_test$p.adj < 0.05, na.rm = TRUE)
      norm_violation <- norm_violation_count >= 1
    },
    error = function(err) { # catch
      parent_error <- trace_error_parent(err)
      norm_test <- paste(
        "Could not compute Shapiro's test for normality due to an error.
                           Presuming that data is not normally distributed.\n",
        parent_error$message
      )
      norm_violation <- TRUE
    }
  )
  
  # no need to log normalize if data are already normally distributed
  if (!norm_violation) {
    return (FALSE)
  }
  
  # test for log-normal distribution of data
  #-group data by independent variable(s) from formula
  log_norm_test <- NULL
  log_norm_violation <- NULL
  log_norm_violation_count <- 0
  log_xdf <- xdf %>% mutate(!!yvar := log(.data[[yvar]], base = xbase))
  tryCatch(
    {
      log_norm_test <- permissive_shapiro(log_xdf, xformula)
      log_norm_violation_count <- sum(log_norm_test$p.adj < 0.05, na.rm = TRUE)
      log_norm_violation <- log_norm_violation_count >= 1
    },
    error = function(err) { # catch
      parent_error <- trace_error_parent(err)
      log_norm_test <- paste(
        "Could not compute Shapiro's test for normality due to an error.
                           Presuming that data is not normally distributed.\n",
        parent_error$message
      )
      log_norm_violation <- TRUE
    }
  )
  
  # log normalize if it works
  if (!log_norm_violation) { 
    return(TRUE)
  }
  
  # log normalize if its better for more groups than not log normalizing
  if (log_norm_violation_count < norm_violation_count) {
    return(TRUE) 
  } else {
    return(FALSE)
  }
  
}

#' Convert a list of character vectors into a single formatted character vector with separating punctuation and conjunction.
#' 
#' @description
#' Creates a formatted character vector from a list of character vectors based on standard English conventions.
#' * Single item lists are returned as-is.
#' * Two item lists are returned with the items separated by the provided `conjunction`.
#' * Three or more item lists are returned with the items separated by `punctuation`.
#' 
#' @param text A vector or list of character vectors that are to be joined.
#' 
#' @param sep A character vector that will be inserted between elements in `text`. (Default = " ")
#' 
#' @param punctuation A character vector that will be inserted between elements in `text` before `sep`. (Default = ",")
#' 
#' @param conjunction A character vecotr that will be inserted between the last two elements in `text`. (Default = "and")
#' 
#' @param oxford If true, inserts `punctuation` before `conjunction` betweeen the last two elements in `text`. (i.e, the Oxford comma) 
#' 
#' @returns Outputs a single character vector after formatting the input text.
#' 
#' @noRd
paste_to_text_list <- function(text, sep = " ", punctuation = ",", conjunction = "and", oxford = TRUE) {
  tryCatch(
    {
      text <- as.character(text)
    },
    error = function(err) {
      errorCondition("Provided elements could not be converted to type 'character'")
    }
  )
  if (length(text) == 1) {
    return(text)
  }
  if (length(text) == 2) {
    return(paste(text, collapse = paste0(sep, conjunction, sep)))
  }
  if (length(text) >= 3) {
    return_string <- paste0(text[-length(text)], collapse = paste0(punctuation, sep))
    if (oxford == TRUE) {
      return_string <- paste0(return_string, ",", sep, conjunction, sep, text[length(text)])
    } else {
      return_string <- paste0(return_string, sep, conjunction, sep, text[length(text)])
    }
    return(return_string)
  }
}

#' Combine individual GLASS-AI image tumor analysis files in a directory.
#' 
#' @description
#' Iterate over each tabular file in `dir_path`, keeping only those images also found in `image_info_df`
#' * Expected file name must match an entry in the "slide_id" column of `image_info_df`.
#' * `.xlsx`, `.xls`, `.csv`, and `.tsv` are all considered valid file types.

#' @param dir_path Formatted character vector containing the path to the directory with the image analysis files produced by GLASS-AI
#' 
#' @param image_info Data frame or character vectors containing image IDs to be included. 
#' 
#' @param image_id_column  Name of the column in `image_info` data frame that contains image IDs to be included.
#' 
#' @returns A data frame containing all individual tumor records found in `dir_path`.
#' 
#' @noRd
import_individual_slide_tumors <- function(dir_path, image_info, image_id_column = "image_id") {
  # validate params
  if (!dir.exists(dir_path)) {
    abort("Directory does not exist.")
  }
  if (class(image_id_column) != "character"){
    abort("`image_id_column` must be a character vector.")
  }
  # get provided image IDs from slide_info
  if ("data.frame" %in% class(image_info)){
    if(image_id_column %in% colnames(image_info)){
      provided_slide_ids <- image_info[[image_id_column]]
    } else {
      abort(paste0("Column `",image_id_column, "` doesn't exist in the provided `image_info_df`."))
    }
  } else if (class(image_info) == "character") {
    provided_slide_ids <- image_info
  } else {
    abort("`image_info` must be a data frame or character vector.")
  }
  
  # get list of files in directory
  file_list <- dir(dir_path, pattern = "\\.(xlsx|xls|csv|tsv)$")

  # filter to files that match an image_id value in slide_info
  matched_files <- tools::file_path_sans_ext(file_list) %in% as.character(provided_slide_ids)
  file_list <- file_list[matched_files]
  
  # read in first file as-is to get headers then concatentate remaining files
  merged_tumor_areas <- read_table_file(file.path(dir_path, file_list[1]))
  merged_tumor_areas$image_id = tools::file_path_sans_ext(file_list[1]) #temporary fix for image_id not including "_adjusted" after manual adjustment
  for (file in file_list[-1]) {
    slide_data <- read_table_file(file.path(dir_path, file))
    slide_data$image_id = tools::file_path_sans_ext(file) #temporary fix for image_id not including "_adjusted" after manual adjustment
    merged_tumor_areas <- full_join(merged_tumor_areas, slide_data)
  }
  return(merged_tumor_areas)
}

remove_lowinfo_terms <- function(xdf, xformula) {
  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]
  # remove subgroup if it's identical to group
  if (sum(c("group", "subgroup") %in% xvars) == 2) {
    if (identical(xdf[["group"]], xdf[["subgroup"]]) |
      nrow(unique(xdf["group"])) == nrow(distinct(xdf, group, subgroup))) {
      xvars <- xvars[xvars != "subgroup"]
      xformula <- remove_terms(xformula, "subgroup")
    }
  }
  # remove subindividual if it's identical to individual or does not add any extra information
  if (sum(c("individual_id", "subindividual_id") %in% xvars) == 2) {
    if ((identical(xdf[["individual_id"]], xdf[["subindividual_id"]])) |
      nrow(unique(xdf["individual_id"])) == nrow(distinct(xdf, individual_id, subindividual_id))) {
      xvars <- xvars[xvars != "subindividual_id"]
      xformula <- remove_terms(xformula, "subindividual_id")
    }
  }
  return(xformula)
}

remove_terms <- function(form, term) {
  fterms <- terms(form)
  fac <- attr(fterms, "factors")
  idx <- which(as.logical(fac[term, ]))
  new_fterms <- drop.terms(fterms, dropx = idx, keep.response = TRUE)
  return(formula(new_fterms))
}

generate_valid_comparisons <- function(xdf, xformula) {
  # get variables from formula
  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]

  full_level_list <- expand.grid(unique(xdf[xvars]))
  valid_comparison_df <- data_frame(A = character(), B = character())
  valid_comparison_count <- 0
  for (icomparison in 1:nrow(full_level_list)) {
    current_comparison <- as.character(unlist(full_level_list[icomparison, ]))
    # build combined grouping variable
    current_comparison_newgroup <- paste0(current_comparison, collapse = ":")

    for (jcomparison in 1:nrow(full_level_list)) {
      # find comparisons that differ by only 1 variable
      test_comparison <- as.character(unlist(full_level_list[jcomparison, ]))
      is_valid <- sum(current_comparison == test_comparison) == length(xvars) - 1
      # store valid comparisons
      if (is_valid) {
        valid_comparison_count <- valid_comparison_count + 1
        # build combined grouping variable
        test_comparison_newgroup <- paste0(test_comparison, collapse = ":")
        # add to list of valid comparisons
        valid_comparison_df <- valid_comparison_df %>% add_row(
          A = current_comparison_newgroup,
          B = test_comparison_newgroup
        )
      }
    }
  }

  # remove duplicate/reverse comparisons
  valid_comparison_df <- valid_comparison_df %>%
    group_by(grp = paste(pmax(A, B), pmin(A, B), sep = "_")) %>%
    filter(row_number() == 1) %>%
    ungroup() %>%
    select(-grp)

  # convert to list of vector pairs to pass as 'comparison' arg in stats test
  valid_comparion_list <- unname(mapply(c, valid_comparison_df$A, valid_comparison_df$B, SIMPLIFY = F))
  return(valid_comparion_list)
}


permissive_shapiro <- function(xdf, xformula, p.adj.method = "holm") {
  # get variables from formula
  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]

  group_validation <- validate_groups(xdf, xformula, min_count = 3, max_count = 5000, exclude_zero_var = TRUE)

  #add explanations for excluded groupings
  group_validation[["small_groups"]] <- group_validation[["small_groups"]] %>%
    mutate(
      variable = yvar, statistic = NA, p = NA,
      note = "Too few individuals in group"
    )
  group_validation[["big_groups"]] <- group_validation[["big_groups"]] %>%
    mutate(
      variable = yvar, statistic = NA, p = NA,
      note = "Too many individuals in group"
    )
  group_validation[["zero_var_groups"]] <- group_validation[["zero_var_groups"]] %>%
    mutate(
      variable = yvar, statistic = NA, p = NA,
      note = "Zero variability in group"
    )
    
    
  if (nrow(group_validation[["valid_groups"]]) > 0) {
    shapiro_result <- suppressMessages(
      xdf %>% semi_join(group_validation[["valid_groups"]], by = xvars) %>%
        group_by(across(all_of(xvars))) %>% shapiro_test(!!as.name(yvar))
    )
    shapiro_result <- suppressMessages(
      full_join(shapiro_result, group_validation[["valid_groups"]]) %>%
        full_join(group_validation[["small_groups"]]) %>%
        full_join(group_validation[["big_groups"]]) %>%
        full_join(group_validation[["zero_var_groups"]]) %>%
        adjust_pvalue(method = p.adj.method) %>%
        relocate(p.adj, n, note, .after = p) %>%
        arrange(across(all_of(xvars)))
    )
  } else {
    shapiro_result <- suppressMessages(
      full_join(group_validation[["small_groups"]], group_validation[["big_groups"]]) %>%
      full_join(group_validation[["zero_var_groups"]]) %>%
      adjust_pvalue(method = p.adj.method) %>%
      relocate(p.adj, n, note, .after = p) %>%
      arrange(across(all_of(xvars))))
  }

  return(shapiro_result)
}

validate_groups <- function(xdf, xformula, min_count = 3, max_count = Inf, exclude_zero_var = TRUE) {
  # get grouping variables from formula
  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]

  group_tally <- xdf %>%
    group_by(across(all_of(xvars))) %>%
    tally()
  
  zero_var_groups <- suppressMessages( 
    xdf %>% 
    group_by(across(all_of(xvars))) %>%
    summarise(variance = sd(!!as.name(yvar))) %>%
    filter(variance == 0)
  )
  
  zero_var_groups <-  suppressMessages(
    group_tally %>% 
    semi_join(zero_var_groups) %>%
    mutate(
      variable = yvar, statistic = NA, p = NA,
      note = "Zero variability in group"
    )
  )

  small_groups <- group_tally %>%
    filter(n < min_count) 
  
  big_groups <- group_tally %>%
    filter(n >= max_count) 
  
    valid_groups <- suppressMessages( 
    group_tally %>% 
    anti_join(small_groups) %>%
    anti_join(big_groups) %>%
    anti_join(zero_var_groups)
  )
    
  out_list <- list(
    "valid_groups" = valid_groups,
    "small_groups" = small_groups,
    "big_groups" = big_groups,
    "zero_var_groups" = zero_var_groups
  )
  
  return(out_list)
}

trace_error_parent <- function(error_obj) {
  while ("parent" %in% names(error_obj)) {
    error_obj <- error_obj$parent
  }
  return(error_obj)
}

add_significance_ggplotly <- function(plotly_obj, pairwise_test, omnibus_test, comparison_list) {
  # make df for setting text above groups in plot
  # get test formula variables from statistical tests
  if (!missing(pairwise_test) && !(sum(class(pairwise_test) == "rstatix_test") == 0)) {
    test.attributes <- attributes(pairwise_test)
    test_vars <- all.vars(test.attributes$args$formula)
    y_var <- test_vars[1]
    x_vars <- test_vars[-1]
  } else {
    errorCondition("Input provided for 'dataframe' was not a dataframe")
  }

  # get plot data from plotly object
  sig_df <- environment(plotly_obj[["x"]][["visdat"]][[1]])[["x"]]
  # map df variable to element in graph
  plot_vars_list <- list()
  var_count <- 0
  for (plot_var in plotly_obj$x$attrs[[1]]) {
    var_count <- var_count + 1
    # only look for variables stored as formulas (e.g., avoid "type")
    if (class(plot_var) == "formula") {
      end_of_formula <- FALSE
      # extract data variable name from nested formulas
      var_name <- plot_var[[2]]
      while (!end_of_formula) {
        # function calls during variable assignment are class = 'call'
        if (is.name(var_name)) {
          plot_vars_list[[names(attr_list)[var_count]]] <- var_name
          break
        }
        var_name <- var_name[[2]]
      }
    }
  }
  # remove entries not associated with variables in actual data
  plot_vars_list <- plot_vars_list[plot_vars_list %in% names(sig_df)]

  # calculate y Position
  # find plotted variables used for grouping (i.e., not y)
  grouping_vars <- plot_vars_list[!(names(plot_vars_list) == "y")]
  sig_df <- sig_df %>%
    group_by(all_of(across(as.character(grouping_vars)))) %>%
    summarise(yPos = max(!!as.name(plot_vars_list[["y"]])) * 1.1)

  # calculate x offset for grouped plots
  if (!("boxmode" %in% names(plotly_obj$x$layout))) {
    plotly_obj$x$layout$boxmode <- "none"
  }
  if (plotly_obj$x$layout$barmode == "group" || plotly_obj$x$layout$boxmode == "group") {
    sig_df <- sig_df %>% mutate(xOffset = as.numeric(!!as.name(plot_vars_list[["x"]])) +
      ((match(!!as.name(plot_vars_list[["colour"]]), group_order) -
        mean(c(1, group_count))) * 0.35))
  }

  for (comparison in 1:nrow(pairwise_test)) {
    NULL
  }
}



print_statistics <- function(stats_summary, omni_test, posthoc_test) {
  # output statistics
  cat("\n<details closed>\n")
  cat("<summary> Statistics Results </summary>\n")
  print_stats_summary(stats_summary)

  if (!(missing(omni_test))) {
    omni_test_kable <- kable(omni_test, caption = "Omnibus test results")
    print(omni_test_kable)
  }
  if (!(missing(posthoc_test))) {
    if (sum(length(omni_test[[6]]) > 1 | omni_test[[6]] != "")) {
      posthoc_test_kable <- kable(posthoc_test, caption = "Posthoc test results")
    } else {
      posthoc_test_kable <- kable(posthoc_test, caption = "Posthoc test results (invalid due to non-significant omnibus test)")
    }
    print(posthoc_test_kable)
  }
  cat("\n</details>\n")
}

#' Format a specific trace or traces in a plotly object.
#' 
#' @description
#' Pass a list of modifications to selected traces in a plotly object. Traces can be filtered by
#' type, mode, and/or or name using regular expressions. 

#' @param plotly_object Plotly object to be formatted.
#' 
#' @param filter_type The `type` of the plotly trace(s) to be formatted (e.g., "box") 
#' 
#' @param filter_mode The `mode` of the plotly trace(s) to be formatted (e.g., "markers")
#' 
#' @param filter_name A regular expression used to match the `name` of the plotly trace(s) to be formatted.
#' 
#' @param ...  Arguments to be merged into the plotly trace(s) using `utils::modifyList()`
#' 
#' @returns A plotly object with the target 
#' 
#' @noRd
format_plotly_trace <- function(plotly_object, filter_type = NULL, filter_mode = NULL, filter_name = NULL, ...) {
  # get list of changes to apply to trace
  input_list <- list(...)
  
  # iterate over each trace in plotly object and pass list to those that pass filters
  trace_index <- 0
  found_trace <- FALSE
  for (plotly_trace in plotly_object$x$data) {
    trace_index <- trace_index + 1
    if ("type" %in% names(plotly_trace) &&
      (is.null(filter_type) || plotly_trace$type == filter_type) &&
      (is.null(filter_mode) || plotly_trace$mode == filter_mode) &&
      (is.null(filter_name) || grepl(filter_name,plotly_trace$name))){
      found_trace <- TRUE
      plotly_object$x$data[[trace_index]] <- modifyList(plotly_object$x$data[[trace_index]], input_list)
    }
  }
  
  if (!found_trace) {
    abort(paste0("No \"", filter_type, "\" traces were found in `plotly_object`"))
  }
  return(plotly_object)
}

format_plotly_legend <- function(plotly_object, legend_group_variable, level_label_list, legend_label_variable = "label", make_multiline = F, split_delimiter = ":", verbose = FALSE) {
  trace_index <- 0
  for (plotly_trace in plotly_object$x$data) {
    trace_index <- trace_index + 1
    # skip "empty" traces (i.e, no name)
    if (plotly_trace$name != "") {
      if (make_multiline) {
        old_name <- plotly_object$x$data[[trace_index]]$name
        plotly_object$x$data[[trace_index]]$name <-
          level_label_list[[legend_label_variable]][[plotly_trace$name]] %>%
          str_replace_all(., split_delimiter, "</br>") %>%
          paste0("</br>", .)
        if (verbose) {
          message(paste0(old_name,":",plotly_object$x$data[[trace_index]]$name))
        }
      } else {
        old_name <- plotly_object$x$data[[trace_index]]$name
        plotly_object$x$data[[trace_index]]$name <- level_label_list[[legend_label_variable]][[plotly_trace$name]]
        if (verbose) {
          message(paste0(old_name,":",plotly_object$x$data[[trace_index]]$name))
        }
      }
      plotly_object$x$data[[trace_index]]$legendgroup <-
        level_label_list[[legend_group_variable]][[plotly_trace$name]]
    }
  }
  return(plotly_object)
}

run_stats_summary <- function(xdf, xformula) {
  # validate input classes
  if (sum(class(xdf) == "dataframe") == 0) {
    errorCondition("Input provided for 'dataframe' was not a dataframe")
  }
  if (class(xformula) == "character") {
    xformula <- as.formula(xformula)
  }
  if (class(xformula) != "formula") {
    errorCondition("Input provided for 'formula' was not of class 'formula' or 'character'")
  }

  # get grouping variables from formula
  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]

  # remove any grouping from dataframe
  xdf <- xdf %>% ungroup()

  # get summary stats
  summary_stats <- xdf %>%
    group_by(across(all_of(xvars))) %>%
    get_summary_stats(!!as.name(yvar), type = "common")

  # test for homogeneity of variance
  homo_var_test <- NULL
  homo_var_violation <- NULL
  # test for homogeneity of variance
  tryCatch(
    {
      homo_var_test <- s20x::levene.test(xformula, xdf, show.table = FALSE)
      homo_var_test <- cbind(
        homo_var_test$df,
        homo_var_test$ss,
        c(paste(homo_var_test$ms), ""),
        c(paste(homo_var_test$f.value), "", ""),
        c(paste(homo_var_test$p.value), "", "")
      )
      dimnames(homo_var_test) <- list(c("Between Groups", "Within Groups", "Total"), c("Df", "Sum Squares", "Mean Square", "F-statistic", "p-value"))
      homo_var_test <- as_tibble(homo_var_test) %>% mutate_all(type.convert, as.is = TRUE)
      homo_var_test$comparison <- c("Between Groups", "Within Groups", "Total")
      homo_var_test <- homo_var_test %>% relocate(comparison, before = Df)
      homo_var_violation <- homo_var_test$`p-value`[[1]] < 0.05
    },
    error = function(err) {
      parent_error <- trace_error_parent(err)
      homo_var_test <- paste(
        "Could not compute Levene test for homogeneity of variance due to an error.
                           Presuming that variance is not homogenous.\n ERROR:",
        parent_error$message
      )
      homo_var_violation <- TRUE
    }
  )

  # test for normal distribution of data
  #-group data by independent variable(s) from formula
  norm_test <- NULL
  norm_violation <- NULL
  tryCatch(
    {
      norm_test <- permissive_shapiro(xdf, xformula)
      norm_violation <- sum(norm_test$p.adj < 0.05, na.rm = TRUE) > 0
    },
    error = function(err) { # catch
      parent_error <- trace_error_parent(err)
      norm_test <- paste(
        "Could not compute Shapiro's test for normality due to an error.
                           Presuming that data is not normally distributed.\n",
        parent_error$message
      )
      norm_violation <- TRUE
    }
  )

  out_list <- list(
    "summary_stats" = summary_stats,
    "homo_var_violated" = homo_var_violation,
    "homo_var_test_results" = homo_var_test,
    "norm_violation" = norm_violation,
    "norm_test_results" = norm_test
  )
  class(out_list) <- c("stats_summary", class(out_list))
  attr(out_list, "data") <- xdf
  attr(out_list, "formula") <- xformula
  return(out_list)
}

print_stats_summary <- function(stats_summary) {
  # print summary statistics table
  out_summary_table <- kable(stats_summary[1], caption = "Summary Statisics")
  print(out_summary_table)
  cat("\n---\n")

  # print homogenity of variance results
  if (!is.null(stats_summary[[2]])) {
    if (stats_summary[[2]] == TRUE) {
      homo_var_table_footnote <- "⚠️ There was a violation of homogeneity of variance in the data.\n"
    } else {
      homo_var_table_footnote <- "✅ All data have equal variance\n"
    }
    out_homo_var_table <- kable(stats_summary[[3]],
      caption = "Levene's homogeneity of variance test"
    )
    print(out_homo_var_table)
    cat(homo_var_table_footnote)
  } else {
    cat("❌ There was an error calculating homogeneity of variance using Lavene's test./n")
  }
  cat("\n---\n")

  # print normality test results
  if (!is.null(stats_summary[[4]])) {
    if (stats_summary[[4]] == TRUE) {
      norm_table_footnote <- "⚠️ There was a violation of normality of distrbution in the data\n"
    } else {
      norm_table_footnote <- "✅ All data have a normal distribution\n"
    }
    out_norm_table <- kable(stats_summary[5],
      caption = "Shapiro's test of normality"
    )
    print(out_norm_table)
    cat(norm_table_footnote)
  } else {
    cat("❌ There was an error calculating normality using Shapiro's test.\n")
  }
  cat("\n---\n")
}

run_omnibus_test <- function(xdf, xformula, useParametric = "auto", useWelch = "auto", stats_summary = NULL) {
  if ("stats_summary" %in% class(xdf)) {
    stats_summary <- xdf
    xdf <- attributes(stats_summary)$data
    xformula <- attributes(stats_summary)$formula
  }

  # validate input classes
  if (class(xformula) == "character") {
    xformula <- as.formula(xformula)
  }
  if (class(xformula) != "formula") {
    errorCondition("Argument provided for 'formula' was not of class 'formula' or 'character'")
  }

  formulaVars <- all.vars(xformula)
  yvar <- formulaVars[1]
  xvars <- formulaVars[-1]

  if ("stats_summary" %in% class(stats_summary)) {
    message("Importing homogeneity of variance test and normality test results from 'stats_summary'.")
    homo_var_violation <- stats_summary[[2]]
    norm_violation <- stats_summary[[4]]
  } else {
    stats_summary <- run_stats_summary(xdf, xformula)
    homo_var_violation <- stats_summary[[2]]
    norm_violation <- stats_summary[[4]]
  }

  if (class(useParametric) == "numeric"){
    if (useParametric > 1 || useParametric < 0) {
      warning("Input value for 'useParametric' must be between 0 and 1.
              Defaulting to 0 ('auto').")
      useParametric <- "auto"
    } else {
      norm_violation_count <- sum(stats_summary[[5]]$`p.adj` < 0.05)
      norm_violation_proportion <- norm_violation_count / length(stats_summary[[5]]$`p.adj`)
      if (norm_violation_proportion > useParametric) {
        useParametric = FALSE
      } else { useParametric = parametric_test_individuals }
    }
  
  }
  if (class(useParametric) != "logical" & useParametric != "auto") {
    warning("Input value for 'useParametric' must be TRUE,FALSE or 'auto'.
            Defaulting to 'auto'.")
    useParametric <- "auto"
  }

  # validate input values
  if (class(useWelch) != "logical" & useWelch != "auto") {
    warning("Input value for 'useParametric' must be TRUE,FALSE or 'auto'.
            Defaulting to 'auto'.")
    useParametric <- "auto"
  }

  # filter for groups of valid sizes (>=3)
  group_validation <- validate_groups(xdf, xformula, min_count = 3)
  
  valid_xdf <- suppressMessages(
    xdf %>% semi_join(group_validation[["valid_groups"]], by = xvars, copy = TRUE) %>%
      # group by variables to reduce comparisons to a single contrast
      group_by(across(all_of(xvars[-1]))) %>%
      # remove levels that don't have multiple groups
      filter(n_distinct(across(xvars[1])) > 1) %>% ungroup()
  )

  if (norm_violation) {
    if (useParametric == TRUE) {
      warning("Data do not conform to Gaussian distribution.
              Consider using a non-parametric test.")
    } else if (useParametric == "auto") {
      message("Data do not conform to Gaussian distribution.
              Using a non-parametric test for analysis.")
      useParametric <- FALSE
    }
  } else {
    if (useParametric == "auto") {
      useParametric <- TRUE
    } else if (useParametric == FALSE) {
      message("Data is normally distributed.
             Consider switching to parametric test.")
    }
  }

  # switch to Welch's ANOVA if needed
  if (useParametric) {
    if (homo_var_violation) {
      if (useWelch == FALSE) {
        mesage("Data has a significant violation of the homogeneity of variance between groups.
                Consider switching to Welch's ANOVA test.")
      } else if (useWelch == "auto") {
        message("Data has a significant violation of the homogeneity of variance between groups.
                Using Welch's ANOVA.")
        useWelch <- TRUE
      }
    } else if (!homo_var_violation) {
      if (useWelch == TRUE) {
        message("Variance between groups is homogenous.
                Consider switching to normal ANOVA test.")
      } else if (useWelch == "auto") {
        useWelch <- FALSE
      }
    }
  } else {
    useWelch <- FALSE
  }

  # perform statistical comparisons
  if (useParametric) {
    if (useWelch) {
      omni.test <- valid_xdf %>%
        welch_anova_test(xformula) %>%
        add_significance("p")
      omni.test$method <- "Welch's ANOVA"
    } else {
      omni.test <- valid_xdf %>%
        anova_test(xformula) %>%
        add_significance("p")
      omni.test$method <- "ANOVA"
    }
  } else {
    omni.test <- valid_xdf %>%
      # group by variables to reduce comparisons to a single contrast
      {if (length(xvars) > 1)
      group_by(.,across(all_of(xvars[1]))) %>%
          kruskal_test(.,as.formula(paste(yvar, "~", xvars[-1])))
      else kruskal_test(.,as.formula(paste(yvar, "~", xvars[1]))) } %>%
      add_significance("p")
    omni.test$method <- "Kruskal-Wallis"
    # reset formula back to original
    attributes(omni.test)$args$formula <- xformula
  }
  class(omni.test) <- c("omnibus_test", class(omni.test))
  return(omni.test)
} # end function: run_omnibus_test

run_posthoc_test <- function(omnibus, comparison_list, useParametric = "auto", fwerCorrectionMethod = "holm") {
  if ("omnibus_test" %in% class(omnibus)) {
    test.attributes <- attributes(omnibus)

    xdf <- test.attributes$args$data
    xformula <- test.attributes$args$formula
    formulaVars <- all.vars(xformula)
    yvar <- formulaVars[1]
    xvars <- formulaVars[-1]

    # make a single grouping variable from formula
    if (length(xvars) > 1) {
      tvar <- paste0(xvars, collapse = ":")
      xdf[tvar] <- apply(xdf[, xvars], 1, paste, collapse = ":")
      xformula <- as.formula(paste(yvar, "~", tvar))
    } else {
      tvar <- xvars
    }
    # make sure both members of each pairwise comparison are present in the data
    xcomparisons <- list()
    icomparisons <- 0
    # only perform comparisons still in data
    for (comparison in comparison_list) {
      if ((comparison[[1]] %in% xdf[[tvar]] &&
        comparison[[2]] %in% xdf[[tvar]])) {
        icomparisons <- icomparisons + 1
        xcomparisons[[icomparisons]] <- comparison
      }
    }

    if (useParametric == "auto") {
      if (sum(c("anova_test", "welch_anova_test") %in% class(omnibus)) > 0) {
        useParametric <- TRUE
      } else if ("kruskal_test" %in% class(omnibus)) {
        useParametric <- FALSE
      } else {
        errorCondition("Argument provided for 'omnibus' was not of class 'anova_test',
                               'welch_anova_test' or 'kruskal_test'.")
      }
    }
    # use info from omnibus test if provided
    if (useParametric == TRUE) {
      posthoc_test <- xdf %>%
        ungroup() %>%
        pairwise_t_test(xformula,
          comparisons = xcomparisons,
          p.adjust.method = fwerCorrectionMethod
        )
      posthoc_test$method <- paste("T-test:", fwerCorrectionMethod)
    } else if (useParametric == FALSE) {
      posthoc_test <- xdf %>%
        ungroup() %>%
        pairwise_wilcox_test(xformula,
          comparisons = xcomparisons,
          p.adjust.method = fwerCorrectionMethod
        )
      posthoc_test$method <- paste("Wilcox:", fwerCorrectionMethod)
    }
    return(posthoc_test)
  } else {
    errorCondition("Argument provided for 'omnibus' was not of class 'omnibus_test'.")
  }
}


# used to find values represented as X% in data tables for conversion to decimals
is.percentage <- function(x) any(grepl("%$", x))

# define function for reading data from excel or delimited text file
read_table_file <- function(file_path) {
  file_type <- tools::file_ext(file_path)
  if (file_type == "xls" | file_type == "xlsx") {
    infile <- read_excel(file_path)
  } else if (file_type == "tsv") {
    infile <- read_tsv(file_path)
  } else if (file_type == "csv") {
    read_csv(file_path)
  } else {
    warning(file_path)
    stop("File type not supported.")
  }
}
# define function for adding subtitles to plotly graphs
ggplotly_subtitle <- function(plot_obj, hoverinfo = NULL) {
  if (!(is.null(plot_obj$labels$title)) && !(is.null(plot_obj$labels$subtitle))) {
    if (!(is.null(hoverinfo))) { # add custom hover tooltip if provided
      ggplotly(plot_obj, tooltip = hoverinfo) %>% layout(title = list(text = paste0(
        plot_obj$labels$title,
        "<br>",
        "<sup>",
        plot_obj$labels$subtitle,
        "</sup>"
      )))
    } else {
      ggplotly(plot_obj) %>% layout(title = list(text = paste0(
        plot_obj$labels$title,
        "<br>",
        "<sup>",
        plot_obj$labels$subtitle,
        "</sup>"
      )))
    }
  } else { # if no subtitle provided in ggplot object
    if (!(is.null(hoverinfo))) { # add custom hover tooltip if provided
      ggplotly(plot_obj, tooltip = hoverinfo)
    } else {
      ggplotly(plot_obj)
    }
  }
}

# define function for flagging outliers in graphs
is_outlier <- function(x, y) {
  return(x < quantile(x, 0.25) - y * IQR(x) | x > quantile(x, 0.75) + y * IQR(x))
}

# define function for making factor levels with unicode characeters
as.factor2 <- function(x) {
  if (is.factor(x)) {
    x
  } else if (!is.object(x) && is.integer(x)) {
    levels <- unique.default(x) # Removed sort()
    f <- match(x, levels)
    levels(f) <- as.character(levels)
    class(f) <- "factor"
    f
  } else {
    factor2(x)
  }
}

factor2 <- function(x = character(), levels, labels = levels, exclude = NA,
                    ordered = is.ordered(x), nmax = NA) {
  if (is.null(x)) {
    x <- character()
  }
  nx <- names(x)
  if (missing(levels)) {
    y <- unique(x, nmax = nmax)
    ind <- 1:length(y) # Changed from sort.list(y)
    y <- as.character(y)
    levels <- unique(y[ind])
  }
  force(ordered)
  exclude <- as.vector(exclude, typeof(x))
  x <- as.character(x)
  levels <- levels[is.na(match(levels, exclude))]
  f <- match(x, levels)
  if (!is.null(nx)) {
    names(f) <- nx
  }
  nl <- length(labels)
  nL <- length(levels)
  if (!any(nl == c(1L, nL))) {
    stop(gettextf(
      "invalid 'labels'; length %d should be 1 or %d",
      nl, nL
    ), domain = NA)
  }
  levels(f) <- if (nl == nL) {
    as.character(labels)
  } else {
    paste0(labels, seq_along(levels))
  }
  class(f) <- c(if (ordered) "ordered", "factor")
  f
}

plotlistlist2tabs <- function(plot_list_list, caption_list,
                              tab_names, tab_level = 2) {
  # iterate over a list of ggplot lists and a matching list of captions to output them into tabset containers of the given header level with the given names
  # Each element of plot_list_list is expected to contain a list of ggplot lists for each element in tab_names in the same order. (e.g. [[plot1_tab1 plot1_tab2 ... plot1_tabN]]).
  # iterate through each tab in tab_names
  for (current_tab in 1:length(tab_names)) {
    # make tabset of tab_level for each tab_name
    cat("\n")
    cat(paste(strrep("#", tab_level), tab_names[current_tab], "\n"))
    cat("\n")

    # iterate through set of plots for each tab in plot_list_list
    for (current_plot in 1:length(plot_list_list)) {
      # output stored plot for current tab in each plot_list
      tryCatch(
        {
          if (plot_list_list[[current_plot]][[current_tab]]$dependencies[[1]]$package == "plotly") {
            print(plot_list_list[[current_plot]][[current_tab]])
          }
        },
        error = function(e) {
          print(htmltools::plotTag(plot_list_list[[current_plot]][[current_tab]],
            alt = paste(
              tab_names[current_tab], ":",
              caption_list[[current_plot]]
            ),
            suppressSize = "xy"
          ))
        }
      )
      # output plot caption. Split long lines. Works with multiline captions.
      line_number <- 0
      wrapped_plot_caption <- c()
      plot_caption <- caption_list[[current_plot]]
      # split carriage returns to vectors
      if (any(str_detect(plot_caption, "\n"))) {
        plot_caption <- str_split(plot_caption, "\n")[[1]]
      }
      # write lines with a blank line between and a blank line at the end
      writeLines(paste(str_wrap(plot_caption), "\n"))
    }
  }
}
```

```{r parameter_definition, message = FALSE, warning = FALSE}
#### FILES####
# path to directory where files are stored
dir_path <- "path/to/analysis/files"
# path to slide info file
path_to_Slide_Info <- file.path(dir_path, "Slide IDs.xlsx")
# path to whole slide summary file
path_to_slide_areas <- file.path(dir_path, "Whole slide summary.xlsx")
# path to merged tumor area file or directory containing individual slide results
path_to_tumor_areas <- file.path(dir_path,"GLASS-AI output")
# define path to folder holding individual IHC stain sub folders labeled by stain
path_to_ihc_analysis_folder <- "" #file.path(dir_path,"IHC stains")
# path to GLASS-AI logfile if you want to include in report
path_to_logfile <- "" #file.path(dir_path, "GLASS-AI output", "GLASS-AI_log_####.txt")
# define output location for data tables used to make each graph
path_to_graph_data <- file.path(dir_path, "Graph Data")


#### FILTERING####
# define optional tumor size threshold in sq. micron
tumor_size_threshold <- 500

#### GROUPING####
# define variables to use for grouping
# grouping variable names should be the column name in the `Slide_Info` spreadsheet
## full_grouping_vars <- c("grouping_var1","grouping_var2",... "grouping_varN")
# grouping variable labels should be the formatted label for each grouping variable
full_grouping_vars <- c("grouping_var")
full_grouping_vars_labels <- c("Grouping Variable")

# define order of groups within each grouping variable
# var_name = c(var_val1, var_val2,... var_valN)
# repeat for each variable included in `full_grouping_vars` above
full_grouping_order <- list(
  genotype_abbreviation = c(
    "group1",
    "group2",
    "group3"
  )
)

full_grouping_order_labels <- full_grouping_order

full_grouping_label <- paste(full_grouping_vars_labels, collapse = " : ")
full_grouping_grade_label <- paste(full_grouping_label, "Tumor Grade", sep = " : ")
full_group_list <- expand_grid(!!!full_grouping_order) %>% unite("full_group", sep = ":")

# define variable used to label individuals
individual_var <- "animal_id" # title of individual variable column in input files
individual_var_label <- "Animal ID"
individual_unit <- "Animal"

# define variable used to label parts from individuals
subindividual_var <- "image_id" # title of sub-individual variable column in input files
subindividual_var_label <- "Slide ID"
subindividual_unit <- "Slide"

#define variables and labels to be used for adding information about individuals to plotly hoverinfo
#set these to be the same as full_grouping_vars and full_grouping_vars_labels to omit
## leaving them empty (or NA, NULL, etc.) breaks select() calls in the report.
sample_info_vars <- c("info1,info2")
sample_info_vars_labels <- c("Information 1","Information 2")


#### GRAPHING###
# define color for each group using colorblind safe palette
group_colors <-  c(
  "black",
  "dodgerblue2",
  "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "gold1",
  "skyblue2",
  "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70",
  "khaki2",
  "maroon",
  "orchid1",
  "deeppink1",
  "blue1",
  "steelblue4",
  "darkturquoise",
  "green1",
  "yellow4",
  "yellow3",
  "darkorange4",
  "brown"
)
# set color scheme for tumor grades (Grade 5, Grade 4, Grade 3, Grade 2, Grade 1)
tumor_grade_labels <- c("Grade 5","Grade 4", "Grade 3", "Grade 2", "Grade 1")
tumor_grade_colors <- c("purple","red", "yellow", "blue", "green")
names(tumor_grade_colors) <- c("5","4","3","2","1")

# should tumor grades be filled with color when used for x-axis?
redundant_fill <- FALSE
# margins for plotly objects
plotly_margins <- list(l = 50, r = 50, b = 50, t = 50)

#### STATS####
# define comparisons of interest for statistics
# multiple grouping variables are separated by a ":"
# use the same values as in `full_grouping_order` above
full_group_comparisons <- list(
  c("group1","group2"),
  c("group1","group3"),
  c("group2","group3")
)

# skip statistics if you know they will not work (i.e., < 3 samples in groups)
skip_stats <- FALSE

# set global parametric/non-parametric test choices
# TRUE: use parametric, FALSE: use non-parametric, "auto": use parametric if no violation of normality (strict)
# values >= 0 and <= 1: use parametric if less than this proportion of groups violate normality assumption 
## this means that useParametric = 1 is equivalent to TRUE and useParametric = 0 is equivalent to FALSE

# comparisons between groups of individuals (Graphs 001 - 027)
parametric_test_individuals = 0
# comparisons between groups of individual tumors (Graphs 027 - 040)
parametric_test_tumors = FALSE

# generate pairwise comparisons for group:tumor_grade combinations
full_group_tumor_grade_comparisons <- list()
comparison_count <- 0
for (i in 1:5) {
  for (j in 1:(length(full_group_comparisons))) {
    comparison_count <- comparison_count + 1
    full_group_tumor_grade_comparisons[[comparison_count]] <-
      c(paste0(full_group_comparisons[[j]][[1]], ":", i), paste0(full_group_comparisons[[j]][[2]], ":", i))
  }
}


#### IHC####
# manually define stain list
ihc_stain_list <- c()
ihc_stain_labels <- c()
```

## Data Import

```{r data_import, message = FALSE, warning = FALSE}
# add truncated logfile
if (file.exists(path_to_logfile)) {
  logfile <- readLines(path_to_logfile)
  image_starts <- which(grepl("----- Start image",logfile))+1
  image_ends <- which(grepl("----- End image",logfile))-1
  image_lines <- as.vector(rbind(logfile[image_starts],logfile[image_ends]))
  header_lines <- logfile[1:(image_starts[1]-2)]
  tail_lines <- logfile[tail(image_ends,1):length(logfile)]
  truncated_logfile <- c(header_lines,image_lines,tail_lines)
  cat("<details><summary>GLASS-AI Analysis logfile (truncated)</Summary>\n")
  cat("```\n")
  cat(truncated_logfile, sep = "\n")
  cat("```\n")
  cat("\n")
  cat("</summary></details>\n\n")
  cat("\n\n")
}


do_ihc_analysis <- TRUE
# skip IHC analysis if no data provided
if (!(file.exists(path_to_ihc_analysis_folder)) || path_to_ihc_analysis_folder == "") {
  path_to_ihc_analysis_folder <- "No IHC analysis to perform."
  do_ihc_analysis <- FALSE
}

# output file names used in analysis to output notebook
kable(
  rbind(
    c("Slide information file:", basename(path_to_Slide_Info)),
    c("GLASS-AI Slide-level summary file:", basename(path_to_slide_areas)),
    c("GLASS-AI Tumor-level summary file:", basename(path_to_tumor_areas)),
    if (do_ihc_analysis) c("GLASS-AI IHC analysis folder:", basename(path_to_ihc_analysis_folder))
  ),
  align = c("l", "l")
)

# read in slide : group pairs from excel file
Slide_Info <- read_table_file(path_to_Slide_Info) %>%
  clean_names(parsing_option = 3) # convert names to snake_case

# make image_id column if it labeled as H&E image ID instead (e.g. for IHC)
if ("h_e_image_id" %in% colnames(Slide_Info)) {
  Slide_Info <- Slide_Info %>% mutate(image_id = h_e_image_id)
}
if ("he_image_id" %in% colnames(Slide_Info)) {
  Slide_Info <- Slide_Info %>% mutate(image_id = he_image_id)
}
if ("hne_image_id" %in% colnames(Slide_Info)) {
  Slide_Info <- Slide_Info %>% mutate(image_id = hne_image_id)
}
if ("slide_id" %in% colnames(Slide_Info)) {
  Slide_Info <- Slide_Info %>% mutate(image_id = slide_id)
}

# read in per slide tumor area sheet; convert names to snake_case; convert percentages to decimals
Slide_Areas <- read_table_file(path_to_slide_areas) %>%
  clean_names(parsing_option = 3) %>% # convert names to snake_case
  mutate_if(is.percentage, ~ as.numeric(sub("%", "", .)) / 100)

# make slide_id column if it labeled as H&E image ID instead (e.g. for IHC)
if ("h_e_image_id" %in% colnames(Slide_Areas)) {
  Slide_Areas <- Slide_Areas %>% mutate(image_id = h_e_image_id)
}
if ("hne_image_id" %in% colnames(Slide_Areas)) {
  Slide_Areas <- Slide_Areas %>% mutate(image_id = hne_image_id)
}
if ("slide_id" %in% colnames(Slide_Areas)) {
  Slide_Areas <- Slide_Areas %>% mutate(image_id = slide_id)
}

# read in merged individual tumor area sheet or import individual files from directory
if (file.exists(path_to_tumor_areas) && !dir.exists(path_to_tumor_areas)) {
  Tumor_Areas <- read_table_file(path_to_tumor_areas)
} else if (dir.exists(path_to_tumor_areas)) {
  Tumor_Areas <- import_individual_slide_tumors(path_to_tumor_areas, as.character(Slide_Info$image_id))
}

# convert names to snake_case and convert percentages to decimals
Tumor_Areas <- Tumor_Areas %>%
  clean_names(parsing_option = 3) %>% # convert names to snake_case
  mutate_if(is.percentage, ~ as.numeric(sub("%", "", .)) / 100)

# make slide_id column if it labeled as H&E image ID instead (e.g. for IHC)
if ("h_e_image_id" %in% colnames(Tumor_Areas)) {
  Tumor_Areas <- Tumor_Areas %>% mutate(image_id = h_e_image_id)
}
if ("hne_image_id" %in% colnames(Tumor_Areas)) {
  Tumor_Areas <- Tumor_Areas %>% mutate(image_id = hne_image_id)
}
if ("slide_id" %in% colnames(Tumor_Areas)) {
  Tumor_Areas <- Tumor_Areas %>% mutate(image_id = slide_id)
}
```

## Data preprocessing

This is where basic data pre-processing and formatting is done.

```{r data_formatting, message=FALSE, warning=FALSE ,collapse = TRUE}
if (redundant_fill) {
  area_fill <- "area_grade"
  tumor_fill <- "tumor_grade"
} else {
  area_fill <- NULL
  tumor_fill <- NULL
}

# make directory to store graph data tables
dir.create(path_to_graph_data)

## Pre-processing of Slide Info
# make full grouping variable
Slide_Info$image_id <- as.character(Slide_Info$image_id)
Slide_Info <- Slide_Info %>%
  rowwise() %>%
  mutate(full_group = paste0(c_across(all_of(full_grouping_vars)), collapse = ":"))

## Pre-processing of Slide_Areas
Slide_Areas$image_id <- as.character(Slide_Areas$image_id)

# map animal group to each slide
Slide_Areas <- Slide_Areas %>% left_join(Slide_Info,
  by = c("image_id" = "image_id"),
  suffix = c("", ".y")
)



Slide_Areas <- Slide_Areas %>% mutate(full_group = factor(full_group, levels = full_group_list[[1]]))
Slide_Areas <- Slide_Areas %>% setNames(gsub("g1", "grade1", names(.))) # change any 'g1' to 'grade1'
Slide_Areas <- Slide_Areas %>% setNames(gsub("g2", "grade2", names(.))) # change any 'g2' to 'grade2'
Slide_Areas <- Slide_Areas %>% setNames(gsub("g3", "grade3", names(.))) # change any 'g3' to 'grade3'
Slide_Areas <- Slide_Areas %>% setNames(gsub("g4", "grade4", names(.))) # change any 'g4' to 'grade4'
Slide_Areas <- Slide_Areas %>% setNames(gsub("g5", "grade5", names(.))) # change any 'g5' to 'grade5'


# copy values to "individual_id" column and move to first column
Slide_Areas <- Slide_Areas %>%
  mutate(individual_id = !!as.name(individual_var)) %>%
  relocate(individual_id)
# copy values to "subindividual_id" column and move to after individual_id
Slide_Areas <- Slide_Areas %>%
  mutate(subindividual_id = !!as.name(subindividual_var)) %>%
  relocate(subindividual_id, .after = individual_id)

# add empty exclude reason column if it doesn't exist
if (!("exclude_reason" %in% colnames(Slide_Areas))) {
  Slide_Areas$exclude_reason <- ""
}

# rearrange slides based on group, then image_id for easier grouping in graphs
Slide_Areas <- Slide_Areas %>%
  arrange(full_group, individual_id, subindividual_id) %>%
  mutate(
    individual_id = factor(individual_id, levels = unique(individual_id)),
    subindividual_id = factor(subindividual_id, levels = unique(subindividual_id))
  )



Slide_Areas <- Slide_Areas %>% rowid_to_column("slide_number")
slide_number_to_id <- Slide_Areas$image_id # use this for x-axis to arrange slides

#add dummy grade5 columns if not present in slide area file
if (sum(str_count(colnames(Slide_Areas),"grade5")) < 2) { 
  Slide_Areas$grade5_percentage_in_image = 0
  Slide_Areas$grade5_area_in_image = 0
}


## Pre-processing of Tumor_Areas
Tumor_Areas$image_id <- as.character(Tumor_Areas$image_id) # convert image_id to string for manual ordering
Tumor_Areas <- Tumor_Areas %>% setNames(gsub("g1", "grade1", names(.))) # change any 'g1' to 'grade1'
Tumor_Areas <- Tumor_Areas %>% setNames(gsub("g2", "grade2", names(.))) # change any 'g2' to 'grade2'
Tumor_Areas <- Tumor_Areas %>% setNames(gsub("g3", "grade3", names(.))) # change any 'g3' to 'grade3'
Tumor_Areas <- Tumor_Areas %>% setNames(gsub("g4", "grade4", names(.))) # change any 'g4' to 'grade4'
Tumor_Areas <- Tumor_Areas %>% setNames(gsub("g5", "grade5", names(.))) # change any 'g5' to 'grade5'

tumor_grade_x_limits = c("1","2","3","4")
#add dummy grade5 columns if not present in tumor files
if (sum(str_count(colnames(Tumor_Areas),"grade5")) < 2) { 
  Tumor_Areas$grade5_percentage = 0
  Tumor_Areas$grade5_area = 0

  count_tumor_grades_analyzed <- 4

} else {
  tumor_grade_x_limits <- c(tumor_grade_x_limits,"5")
  count_tumor_grades_analyzed <- 5
  Tumor_Areas <- Tumor_Areas %>% mutate(grade5_area = ifelse(is.na(grade5_area), 0, grade5_area),
                                        grade5_percentage = ifelse(is.na(grade5_percentage), 0, grade5_percentage)
                                                                   )
}



# map animal group to each tumor based on image_id; relocate group column to after image_id
Tumor_Areas <- Tumor_Areas %>%
  left_join(select(Slide_Areas, "full_group", full_grouping_vars, sample_info_vars, "slide_number", "image_id", "individual_id", "subindividual_id"),
    by = c("image_id" = "image_id"),
    suffix = c("", ".y")
  ) %>%
  relocate("full_group", .after = "image_id")

Tumor_Areas$tumor_id <- formatC(Tumor_Areas$tumor_id, width = 4, format = "d", flag = "0") # add leading zeros to tumor_id


# add empty exclude reason column if it doesn't exist
if (!("exclude_reason" %in% colnames(Tumor_Areas))) {
  Tumor_Areas$exclude_reason <- ""
}

if ("grade_assign_method" %in% colnames(Tumor_Areas)) {
  grade_assignment_method <- paste0("Overall tumor grades were assigned during GLASS-AI analysis (", Tumor_Areas$grade_assign_method[1], ").")
} else {
  # assign overall grades to tumors using highest grade with ≥ 10% of total area
  Tumor_Areas <- Tumor_Areas %>% mutate(
    tumor_grade =
      ifelse(grade5_percentage >= 0.1, "5",
        ifelse(grade4_percentage >= 0.1, "4",
          ifelse(grade3_percentage >= 0.1, "3",
            ifelse(grade2_percentage >= 0.1, "2",
              "1"
          )
        )
      )
    )
  )
  grade_assignment_method <- "Overall tumor grades were assigned based on the highest grade present that comprised ≥ 10% of the tumor's area."
}


Tumor_Areas$tumor_grade <- factor(Tumor_Areas$tumor_grade, levels = rev(tumor_grade_x_limits)) # convert tumor_grade to factor

Tumor_Areas <- Tumor_Areas %>%
  rowwise() %>%
  mutate(grades_present_in_tumor = sum(
    (grade1_area > 0),
    (grade2_area > 0),
    (grade3_area > 0),
    (grade4_area > 0),
    (grade5_area > 0),
    na.rm = TRUE
  ))

# calculate Shannon Diversity Index for each tumor
Tumor_Areas <- Tumor_Areas %>%
  rowwise() %>%
  mutate(shannon_diversity_index = -sum(
    (grade1_percentage * log(grade1_percentage)),
    (grade2_percentage * log(grade2_percentage)),
    (grade3_percentage * log(grade3_percentage)),
    (grade4_percentage * log(grade4_percentage)),
    (grade5_percentage * log(grade5_percentage)),
    na.rm = TRUE
    )
  )

# calculate Shannon Equitability Index for each tumor
Tumor_Areas <- Tumor_Areas %>%
  rowwise() %>%
  mutate(shannon_equitability_index = shannon_diversity_index / log(grades_present_in_tumor))
# replace NaN errors with 0 (i.e., tumors with a single grade present have SEI = 0)
Tumor_Areas$shannon_equitability_index[is.nan(Tumor_Areas$shannon_equitability_index)] <- 0

# get counts of grouping variables in data
full_group_count <- length(unique(Slide_Areas$full_group))
individual_count <- length(unique(Slide_Areas$individual_id))
subindividual_count <- length(unique(Slide_Areas$subindividual_id))



# make slide_number a factor for sorting of Slide_Areas and Tumor_Areas
Slide_Areas$slide_number <- factor(Slide_Areas$slide_number, levels = c(1:subindividual_count))
Tumor_Areas$slide_number <- factor(Tumor_Areas$slide_number, levels = c(1:subindividual_count))

# make unique tumor IDs (UID)
Tumor_Areas <- Tumor_Areas %>%
  mutate(tumor_uid = paste(as.character(image_id),
    as.character(tumor_id),
    sep = "."
  ))
```

``` {r plot_formatting, include = FALSE}

# get combinations of group and tumor_grade
full_group_count <- nrow(full_group_list)
full_group_tumor_grade_level_cross <-
  expand_grid(full_group_list, c(1:5))


# (full_group,tumor_grade)
full_group_tumor_grade_levels <- paste0(
  "(", full_group_tumor_grade_level_cross[[1]], ",",
  full_group_tumor_grade_level_cross[[2]], ")"
)
# (tumor_grade,full_group)
tumor_grade_full_group_levels <- paste0(
  "(", full_group_tumor_grade_level_cross[[2]], ",",
  full_group_tumor_grade_level_cross[[1]], ")"
)
# combine into single vector with both (group,tumor_grade) and (tumor_grade_group)
grouping_levels <- c(full_group_tumor_grade_levels, tumor_grade_full_group_levels)

# get combinations of group_labels and tumor_grade_labels "full_group_label:tumor_grade_label"
full_group_labels <- expand_grid(!!!full_grouping_order_labels) %>%
  unite("label", sep = ":")
full_group_tumor_grade_labels <- expand_grid(full_group_labels, rev(tumor_grade_labels)) %>% unite("label", sep = ":")
full_group_tumor_grade_labels <- setNames(rep(full_group_tumor_grade_labels[[1]], 2), grouping_levels)

group_label_list <- setNames(
  rep(full_group_labels[[1]],
    2,
    each = 5
  ),
  grouping_levels
)
tumor_grade_label_list <- setNames(
  rep(rev(tumor_grade_labels),
    2 * full_group_count,
    each = 1
  ),
  grouping_levels
)

full_group_grade_info_list <- setNames(
  list(
    full_group_tumor_grade_labels,
    tumor_grade_label_list,
    group_label_list
  ),
  c("label", "tumor_grade", "full_group")
)
full_group_info_list <- setNames(list(setNames(full_group_labels[[1]], full_group_list[[1]])), "full_group")
tumor_grade_info_list <- setNames(list(setNames(tumor_grade_labels, c(1:5))), "tumor_grade")
rm(group_tumor_grade_level_cross, group_tumor_grade_levels, tumor_grade_group_levels, grouping_levels, group_tumor_grade_labels, group_label_list, tumor_grade_label_list)

present_full_group_labels <- data.frame(label = full_group_labels$label[full_group_labels$label %in% Slide_Areas$full_group])
present_full_group_labels <- present_full_group_labels %>% mutate(multiline = str_replace_all(label, ":", "\n"))
```

```{r ihc_processing, message = FALSE, warning = FALSE}
# get list of IHC stains by looking for subfolders
if (do_ihc_analysis) {
  # skip IHC analysis if there are no stain-specific subfolders
  stain_count <- length(ihc_stain_list)
  do_ihc_analysis <- stain_count > 0
  # set up table to read in per tumor IHC analysis
  ihc_tumor_counts <- tibble()
  ihc_tumor_counts_column_names <- c(
    "h_e_image_id",
    "stain_image_id",
    "tumor_id",
    "positive_nuclei_grade1",
    "positive_nuclei_grade2",
    "positive_nuclei_grade3",
    "positive_nuclei_grade4",
    "250micron_positive_nuclei",
    "150micron_positive_nuclei",
    "100micron_positive_nuclei",
    "50micron_positive_nuclei",
    "negative_nuclei_grade1",
    "negative_nuclei_grade2",
    "negative_nuclei_grade3",
    "negative_nuclei_grade4",
    "total_positive_nuclei_in_tumor",
    "total_negative_nuclei_in_tumor",
    "total_number_nuclei_in_tumor"
  )

  # output group_var to output notebook
  cat(paste("Analyzing data using", paste("'", full_grouping_label, "'", sep = ""), "as grouping variable.\n"))
  cat(paste("Found", length(full_grouping_order_labels), "groups using selected grouping variable\n"))
  cat("Analysis groups:", paste(full_grouping_order_labels, collapse = ", "), "\n")
  cat(paste("Found", length(ihc_stain_list), "sets of data for IHC analysis\n"))
  cat("IHC stains:", paste(ihc_stain_labels, collapse = ", "), "\n")

  # iterate through each IHC stain to read in data and join to existing Slide_Areas and Tumor_Areas tables
  for (stain in ihc_stain_list) {
    path_to_ihc_slide_counts <- file.path(path_to_ihc_analysis_folder, stain, "Whole_Slide_Summary(Positive-Negative_Nuclei_counts).csv")

    # prefix columns with IHC stain name except first column "h_e_image_id"
    input_col_names <- ihc_slide_counts_column_names[1]
    input_col_names <- append(input_col_names, paste(stain,
      ihc_slide_counts_column_names[2:17],
      sep = "_"
    ))

    # read IHC stain slide summary file.
    ihc_slide_counts <- read_csv(path_to_ihc_slide_counts,
      col_names = input_col_names,
      # Skip first row since column names are pre-defined above
      skip = 1
    )

    # add column for total positive stained nuclei in tumor regions
    newcol <- paste(stain, "total_positive_nuclei_in_tumors", sep = "_")
    ihc_slide_counts <- ihc_slide_counts %>%
      rowwise() %>%
      mutate(!!newcol := sum(
        !!(as.name(paste(stain, "positive_nuclei_grade1", sep = "_"))),
        !!(as.name(paste(stain, "positive_nuclei_grade2", sep = "_"))),
        !!(as.name(paste(stain, "positive_nuclei_grade3", sep = "_"))),
        !!(as.name(paste(stain, "positive_nuclei_grade4", sep = "_")))
      ))

    # add column for total negative nuclei in tumor regions
    newcol <- paste(stain, "total_negative_nuclei_in_tumors", sep = "_")
    ihc_slide_counts <- ihc_slide_counts %>% mutate(!!newcol := sum(
      !!(as.name(paste(stain, "negative_nuclei_grade1", sep = "_"))),
      !!(as.name(paste(stain, "negative_nuclei_grade2", sep = "_"))),
      !!(as.name(paste(stain, "negative_nuclei_grade3", sep = "_"))),
      !!(as.name(paste(stain, "negative_nuclei_grade4", sep = "_")))
    ))

    # add column for total nuclei in tumor regions
    newcol <- paste(stain, "total_number_nuclei_in_tumors", sep = "_")
    ihc_slide_counts <- ihc_slide_counts %>% mutate(!!newcol := sum(
      !!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_"))),
      !!(as.name(paste(stain, "total_negative_nuclei_in_tumors", sep = "_")))
    ))

    # add columns for proportion of positive nuclei in each grade region
    newcol1 <- paste(stain, "positive_nuclei_percent_in_grade1", sep = "_")
    newcol2 <- paste(stain, "positive_nuclei_percent_in_grade2", sep = "_")
    newcol3 <- paste(stain, "positive_nuclei_percent_in_grade3", sep = "_")
    newcol4 <- paste(stain, "positive_nuclei_percent_in_grade4", sep = "_")
    ihc_slide_counts <- ihc_slide_counts %>% mutate(
      !!newcol1 := (!!(as.name(paste(stain, "positive_nuclei_grade1", sep = "_"))) /
        !!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_")))),
      !!newcol2 := (!!(as.name(paste(stain, "positive_nuclei_grade2", sep = "_"))) /
        !!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_")))),
      !!newcol3 := (!!(as.name(paste(stain, "positive_nuclei_grade3", sep = "_"))) /
        !!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_")))),
      !!newcol4 := (!!(as.name(paste(stain, "positive_nuclei_grade4", sep = "_"))) /
        !!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_"))))
    )

    # add column for proportion of nuclei that are positive in each grade region
    newcol1 <- paste(stain, "grade1_percent_positive_nuclei", sep = "_")
    newcol2 <- paste(stain, "grade2_percent_positive_nuclei", sep = "_")
    newcol3 <- paste(stain, "grade3_percent_positive_nuclei", sep = "_")
    newcol4 <- paste(stain, "grade4_percent_positive_nuclei", sep = "_")
    ihc_slide_counts <- ihc_slide_counts %>% mutate(
      !!newcol1 := (!!(as.name(paste(stain, "positive_nuclei_grade1", sep = "_"))) /
        (!!(as.name(paste(stain, "positive_nuclei_grade1", sep = "_"))) +
          !!(as.name(paste(stain, "negative_nuclei_grade1", sep = "_"))))),
      !!newcol2 :=
        (!!(as.name(paste(stain, "positive_nuclei_grade2", sep = "_"))) /
          (!!(as.name(paste(stain, "positive_nuclei_grade2", sep = "_"))) +
            !!(as.name(paste(stain, "negative_nuclei_grade2", sep = "_"))))),
      !!newcol3 :=
        (!!(as.name(paste(stain, "positive_nuclei_grade3", sep = "_"))) /
          (!!(as.name(paste(stain, "positive_nuclei_grade3", sep = "_"))) +
            !!(as.name(paste(stain, "negative_nuclei_grade3", sep = "_"))))),
      !!newcol4 :=
        (!!(as.name(paste(stain, "positive_nuclei_grade4", sep = "_"))) /
          (!!(as.name(paste(stain, "positive_nuclei_grade4", sep = "_"))) +
            !!(as.name(paste(stain, "negative_nuclei_grade4", sep = "_")))))
    )

    # convert stained slide IDs to character for joining
    ihc_slide_counts$h_e_image_id <- as.character(ihc_slide_counts$h_e_image_id)

    # ihc_slide_counts[,2] = apply(ihc_slide_counts[,2], 2, function(x) as.character(x));
    # join ihc_slide_counts to Slide_Areas
    Slide_Areas <- Slide_Areas %>%
      left_join(ihc_slide_counts,
        by = c("image_id" = "h_e_image_id"),
        suffix = c("", ".y")
      )


    # add column for the density of positive cells in each grade region
    newcol1 <- paste(stain, "positive_grade1_density", sep = "_")
    newcol2 <- paste(stain, "positive_grade2_density", sep = "_")
    newcol3 <- paste(stain, "positive_grade3_density", sep = "_")
    newcol4 <- paste(stain, "positive_grade4_density", sep = "_")
    Slide_Areas <- Slide_Areas %>% mutate(
      !!newcol1 := (!!(as.name(paste(stain, "positive_nuclei_grade1", sep = "_"))) /
        (grade1_area_in_slide / (1000^2))),
      !!newcol2 := (!!(as.name(paste(stain, "positive_nuclei_grade2", sep = "_"))) /
        (grade2_area_in_slide / (1000^2))),
      !!newcol3 := (!!(as.name(paste(stain, "positive_nuclei_grade3", sep = "_"))) /
        (grade3_area_in_slide / (1000^2))),
      !!newcol4 := (!!(as.name(paste(stain, "positive_nuclei_grade4", sep = "_"))) /
        (grade4_area_in_slide / (1000^2)))
    )

    # add column for the density of positive cells in the entire slide, normal, and tumor areas
    newcol1 <- paste(stain, "positive_density_in_slide", sep = "_")
    newcol2 <- paste(stain, "positive_density_in_normal", sep = "_")
    newcol3 <- paste(stain, "positive_density_in_tumor", sep = "_")
    Slide_Areas <- Slide_Areas %>% mutate(
      !!newcol1 := (!!(as.name(paste(stain, "total_positive_nuclei_in_slide", sep = "_"))) /
        (total_tissue_area_in_slide / (1000^2))),
      !!newcol2 := (!!(as.name(paste(stain, "total_positive_nuclei_in_slide", sep = "_"))) -
        !!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_"))) /
          ((total_tissue_area_in_slide - total_tumor_area_in_slide) / (1000^2))),
      !!newcol3 := (!!(as.name(paste(stain, "total_positive_nuclei_in_tumors", sep = "_"))) /
        (total_tumor_area_in_slide / (1000^2)))
    )

    path_to_ihc_tumor_counts <- file.path(path_to_ihc_analysis_folder, stain, "merged_counts.csv")
    # prefix columns with IHC stain name except "h_e_image_id" and "tumor_id"
    input_col_names <- ihc_tumor_counts_column_names[1:3]
    # append stain to "stain_image_id"
    input_col_names[2] <- paste(stain, input_col_names[2], sep = "_")
    input_col_names <- append(
      input_col_names,
      paste(stain,
        ihc_tumor_counts_column_names[4:18],
        sep = "_"
      )
    )

    # read IHC stain individual tumor file.
    ihc_tumor_counts <- read_csv(path_to_ihc_tumor_counts,
      col_names = input_col_names,
      # Skip first row since column names are pre-defined above
      skip = 1
    )

    ihc_tumor_counts$h_e_image_id <- as.character(ihc_tumor_counts$h_e_image_id)
    # generate tumorUIDs for joining to Tumor_Area table
    ihc_tumor_counts <- ihc_tumor_counts %>%
      mutate(tumor_uid = paste(as.character(h_e_image_id),
        formatC(tumor_id, width = 4, flag = "0"),
        sep = "."
      ))

    # join ihc_slide_counts to Tumor_Areas
    Tumor_Areas <- Tumor_Areas %>% left_join(ihc_tumor_counts,
      by = c("tumor_uid" = "tumor_uid"),
      suffix = c("", ".y")
    )
  }

  # generate variable names for plotting IHC results
  # initialize storage variables
  ## positive cell count in areas of each grade area (#pos in grade X)
  stain_positive_grade1_count <- NULL
  stain_positive_grade2_count <- NULL
  stain_positive_grade3_count <- NULL
  stain_positive_grade4_count <- NULL
  ## percent of positive cells found in each grade area (#pos in grade X / total #pos in all grade areas)
  stain_positive_grade1_percent <- NULL
  stain_positive_grade2_percent <- NULL
  stain_positive_grade3_percent <- NULL
  stain_positive_grade4_percent <- NULL
  ## peritumor positive cell counts (#pos within 0-50, 51-100,101-150, and 151-250 microns of tumor edges)
  stain_250micron_positive_count <- NULL
  stain_150micron_positive_count <- NULL
  stain_100micron_positive_count <- NULL
  stain_50micron_positive_count <- NULL
  ## negative cell count in areas of each grade (#neg in grade X)
  stain_negative_grade1_count <- NULL
  stain_negative_grade2_count <- NULL
  stain_negative_grade3_count <- NULL
  stain_negative_grade4_count <- NULL
  ## total cell count in slide (total #pos, total #neg, total #pos+#neg)
  stain_total_positive_in_slide_count <- NULL
  stain_total_negative_in_slide_count <- NULL
  stain_total_nuclei_in_slide_count <- NULL
  ## total cell count in tumors(total #pos in tumors, total #neg in tumors, total #pos+#neg in tumors)
  stain_total_positive_in_tumors_count <- NULL
  stain_total_negative_in_tumors_count <- NULL
  stain_total_nuclei_in_tumors_count <- NULL
  ## percent of cells in each area grade that are positive (#pos in grade X/ #pos+#neg in Grade X)
  grade1_percent_positive_nuclei <- NULL
  grade2_percent_positive_nuclei <- NULL
  grade3_percent_positive_nuclei <- NULL
  grade4_percent_positive_nuclei <- NULL
  ## density of positive cells in each area grade (#pos in grade X / area of grade X)
  stain_positive_grade1_density <- NULL
  stain_positive_grade2_density <- NULL
  stain_positive_grade3_density <- NULL
  stain_positive_grade4_density <- NULL
  ## density of positive cells in whole slide, normal, and tumors
  stain_positive_density_in_slide <- NULL
  stain_positive_density_in_normal <- NULL
  stain_positive_density_in_tumor <- NULL


  # generate variable names for each IHC stain
  for (stain in ihc_stain_list) {
    stain_positive_grade1_count <- c(
      stain_positive_grade1_count,
      paste(stain, "positive_nuclei_grade1", sep = "_")
    )
    stain_positive_grade2_count <- c(
      stain_positive_grade2_count,
      paste(stain, "positive_nuclei_grade2", sep = "_")
    )
    stain_positive_grade3_count <- c(
      stain_positive_grade3_count,
      paste(stain, "positive_nuclei_grade3", sep = "_")
    )
    stain_positive_grade4_count <- c(
      stain_positive_grade4_count,
      paste(stain, "positive_nuclei_grade4", sep = "_")
    )
    stain_positive_grade1_percent <- c(
      stain_positive_grade1_percent,
      paste(stain, "positive_nuclei_percent_in_grade1", sep = "_")
    )
    stain_positive_grade2_percent <- c(
      stain_positive_grade2_percent,
      paste(stain, "positive_nuclei_percent_in_grade2", sep = "_")
    )
    stain_positive_grade3_percent <- c(
      stain_positive_grade3_percent,
      paste(stain, "positive_nuclei_percent_in_grade3", sep = "_")
    )
    stain_positive_grade4_percent <- c(
      stain_positive_grade4_percent,
      paste(stain, "positive_nuclei_percent_in_grade4", sep = "_")
    )
    stain_250micron_positive_count <- c(
      stain_250micron_positive_count,
      paste(stain, "250micron_positive_nuclei", sep = "_")
    )
    stain_150micron_positive_count <- c(
      stain_150micron_positive_count,
      paste(stain, "150micron_positive_nuclei", sep = "_")
    )
    stain_100micron_positive_count <- c(
      stain_100micron_positive_count,
      paste(stain, "100micron_positive_nuclei", sep = "_")
    )
    stain_50micron_positive_count <- c(
      stain_50micron_positive_count,
      paste(stain, "50micron_positive_nuclei", sep = "_")
    )
    stain_negative_grade1_count <- c(
      stain_negative_grade1_count,
      paste(stain, "negative_nuclei_grade1", sep = "_")
    )
    stain_negative_grade2_count <- c(
      stain_negative_grade2_count,
      paste(stain, "negative_nuclei_grade2", sep = "_")
    )
    stain_negative_grade3_count <- c(
      stain_negative_grade3_count,
      paste(stain, "negative_nuclei_grade3", sep = "_")
    )
    stain_negative_grade4_count <- c(
      stain_negative_grade4_count,
      paste(stain, "negative_nuclei_grade4", sep = "_")
    )
    stain_total_positive_in_slide_count <- c(
      stain_total_positive_in_slide_count,
      paste(stain, "total_positive_nuclei_in_slide", sep = "_")
    )
    stain_total_negative_in_slide_count <- c(
      stain_total_negative_in_slide_count,
      paste(stain, "total_negative_nuclei_in_slide", sep = "_")
    )
    stain_total_nuclei_in_slide_count <- c(
      stain_total_nuclei_in_slide_count,
      paste(stain, "total_number_nuclei_in_slide", sep = "_")
    )
    stain_total_positive_in_tumors_count <- c(
      stain_total_positive_in_tumors_count,
      paste(stain, "total_positive_nuclei_in_tumors", sep = "_")
    )
    stain_total_negative_in_tumors_count <- c(
      stain_total_negative_in_tumors_count,
      paste(stain, "total_negative_nuclei_in_tumors", sep = "_")
    )
    stain_total_nuclei_in_tumors_count <- c(
      stain_total_nuclei_in_tumors_count,
      paste(stain, "total_number_nuclei_in_tumors", sep = "_")
    )
    grade1_percent_positive_nuclei <- c(
      grade1_percent_positive_nuclei,
      paste(stain, "grade1_percent_positive_nuclei", sep = "_")
    )
    grade2_percent_positive_nuclei <- c(
      grade2_percent_positive_nuclei,
      paste(stain, "grade2_percent_positive_nuclei", sep = "_")
    )
    grade3_percent_positive_nuclei <- c(
      grade3_percent_positive_nuclei,
      paste(stain, "grade3_percent_positive_nuclei", sep = "_")
    )
    grade4_percent_positive_nuclei <- c(
      grade4_percent_positive_nuclei,
      paste(stain, "grade4_percent_positive_nuclei", sep = "_")
    )
    stain_positive_grade1_density <- c(
      stain_positive_grade1_density,
      paste(stain, "positive_grade1_density", sep = "_")
    )
    stain_positive_grade2_density <- c(
      stain_positive_grade2_density,
      paste(stain, "positive_grade2_density", sep = "_")
    )
    stain_positive_grade3_density <- c(
      stain_positive_grade3_density,
      paste(stain, "positive_grade3_density", sep = "_")
    )
    stain_positive_grade4_density <- c(
      stain_positive_grade4_density,
      paste(stain, "positive_grade4_density", sep = "_")
    )
    stain_positive_density_in_slide <- c(
      stain_positive_density_in_slide,
      paste(stain, "positive_density_in_slide", sep = "_")
    )
    stain_positive_density_in_normal <- c(
      stain_positive_density_in_normal,
      paste(stain, "positive_density_in_normal", sep = "_")
    )
    stain_positive_density_in_tumor <- c(
      stain_positive_density_in_tumor,
      paste(stain, "positive_density_in_tumor", sep = "_")
    )
  }
}
```

<details>

<summary>Slide Details</summary>

```{r, message = FALSE, warning = FALSE,}
kable(Slide_Info, caption = "Table 1: Slide Information")
```

</summary>

</details>

<details>

<summary>Group Comparisons</summary>

```{r, message = FALSE, warning = FALSE,}
kable(as.data.frame(matrix(unlist(full_group_comparisons), ncol = 2, byrow = TRUE)) %>% setNames(c("Group 1", "Group2")), caption = "Table 2: Comparisons to be made")
```

</summary>

## Data Filtering

```{r tumor_size_filtering, message = FALSE, warning= FALSE}
if (tumor_size_threshold > 0) {
  Tumor_Areas <- Tumor_Areas %>% filter(total_tumor_area >= tumor_size_threshold)
  cat(paste(c("Filtered out tumors below", tumor_size_threshold, "sq. microns."), collapse = " "))
  
  filtered_tumor_totals <- Tumor_Areas %>%
    group_by(image_id) %>%
    mutate(
      grade1_area_in_image = replace_na(sum(grade1_area),0),
      grade2_area_in_image = replace_na(sum(grade2_area),0),
      grade3_area_in_image = replace_na(sum(grade3_area),0),
      grade4_area_in_image = replace_na(sum(grade4_area),0),
      grade5_area_in_image = replace_na(sum(grade5_area),0),
      total_tumor_area_in_image = replace_na(sum(total_tumor_area),0),
      grade1_percentage_in_image = replace_na(grade1_area_in_image / total_tumor_area_in_image,0),
      grade2_percentage_in_image = replace_na(grade2_area_in_image / total_tumor_area_in_image,0),
      grade3_percentage_in_image = replace_na(grade3_area_in_image / total_tumor_area_in_image,0),
      grade4_percentage_in_image = replace_na(grade4_area_in_image / total_tumor_area_in_image,0),
      grade5_percentage_in_image = replace_na(grade5_area_in_image / total_tumor_area_in_image,0),
      number_of_tumors = n()
    ) %>%
    add_count(image_id,tumor_grade, name = "number_of_graded_tumors") %>% 
    group_by(image_id,tumor_grade) %>%
    slice(1) %>%
    select(
      image_id,
      grade1_percentage_in_image,
      grade2_percentage_in_image,
      grade3_percentage_in_image,
      grade4_percentage_in_image,
      grade5_percentage_in_image,
      grade1_area_in_image,
      grade2_area_in_image,
      grade3_area_in_image,
      grade4_area_in_image,
      grade5_area_in_image,
      total_tumor_area_in_image,
      number_of_tumors,
      number_of_graded_tumors) %>% 
    pivot_wider(names_from = tumor_grade, names_glue = "grade{tumor_grade}_count_in_image", values_from = number_of_graded_tumors)
  
  Slide_Areas$number_of_tumors[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$number_of_tumors
  Slide_Areas$grade1_percentage_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade1_percentage_in_image
  Slide_Areas$grade2_percentage_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade2_percentage_in_image
  Slide_Areas$grade3_percentage_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade3_percentage_in_image
  Slide_Areas$grade4_percentage_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade4_percentage_in_image
  Slide_Areas$grade5_percentage_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade5_percentage_in_image
  Slide_Areas$grade1_area_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade1_area_in_image
  Slide_Areas$grade2_area_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade2_area_in_image
  Slide_Areas$grade3_area_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade3_area_in_image
  Slide_Areas$grade4_area_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade4_area_in_image
  Slide_Areas$grade5_area_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$grade5_area_in_image
  Slide_Areas$total_tumor_area_in_image[match(filtered_tumor_totals$image_id, Slide_Areas$image_id)] <- filtered_tumor_totals$total_tumor_area_in_image
} else {
  cat("Not filtering tumors based on individual tumor size.")
}
```

```{r remove_unmapped_slides, message = FALSE, warning = FALSE, class.output="bg-warning"}
# remove slides that don't have grouping variable
Slide_Areas_unmapped <- Slide_Areas %>% filter(rowSums(across(full_grouping_vars, ~ is.na(.))) > 0)
Slide_Areas <- Slide_Areas %>% anti_join(Slide_Areas_unmapped)
individual_count <- length(unique(Slide_Areas[[individual_var]]))

# omit tumors from removed slides
Tumor_Areas_unmapped <- Tumor_Areas %>% semi_join(Slide_Areas_unmapped, by = "image_id")
Tumor_Areas <- Tumor_Areas %>% anti_join(Tumor_Areas_unmapped)
slide_number_to_id <- setdiff(slide_number_to_id, Slide_Areas_unmapped$image_id)

if (length(Slide_Areas_unmapped$image_id) > 0 && length(Slide_Areas$image_id) > 0) {
  cat(paste(c(
    "Found", length(Slide_Areas_unmapped$image_id), "slides containing",
    length(Tumor_Areas_unmapped$image_id), "tumors that were unable to be grouped based on the selected grouping variable.
      \nThese slides and their tumors will be excluded from analysis."
  ), collapse = " "))
  kable(select(Slide_Areas_unmapped, "image_id", "animal_id", full_group, "number_of_tumors"), caption = "Ungrouped Slides")
} else if (length(Slide_Areas_unmapped$image_id) > 0 && length(Slide_Areas$image_id) == 0) {
  cat("No slides were succesfully grouped based on selected grouping variable.")
} else {
  cat("All slides successfully grouped based on selected grouping variable")
}

if (do_ihc_analysis) {
  for (stain in ihc_stain_list) {
    expected_stained_slides <- unlist(unique(na.omit(select(Slide_Info, paste(tolower(stain), "image_id", sep = "_")))))
    found_stained_slides <- unlist(unique(na.omit(select(Slide_Areas, paste(stain, "image_id", sep = "_")))))
    missing_stained_slides <- setdiff(expected_stained_slides, found_stained_slides)
    extra_stained_slides <- setdiff(found_stained_slides, expected_stained_slides)

    if (length(missing_stained_slides) > 0 || length(extra_stained_slides) > 0) {
      cat(paste(c("Found", length(missing_stained_slides), stain, "stained slides missing:\n",
        missing_stained_slides,
        "\nFound", length(extra_stained_slides), stain, "stained slides without a matching H&E slide defined.\n",
        extra_stained_slides, "\n",
        collapse = " "
      )))
    }
  }
}
```

```{r filter_out_excluded_slides, message = FALSE, warning = FALSE, class.output="bg-warning"}
# find excluded slides based on 'exclude_reason' in slide definition sheet
if ("exclude_reason" %in% colnames(Slide_Info)) {
  excluded_slides <- Slide_Info %>% filter(!is.na(exclude_reason))
  Slide_Areas_excluded <- Slide_Areas %>%
    filter(image_id %in% as.character(excluded_slides$image_id))

  Slide_Areas <- anti_join(Slide_Areas, Slide_Areas_excluded)
  slide_number_to_id <- setdiff(slide_number_to_id, Slide_Areas_excluded$image_id)

  Tumor_Areas_excluded <- Tumor_Areas %>% filter(image_id %in% as.character(excluded_slides$image_id))
  Tumor_Areas <- Tumor_Areas %>% anti_join(Tumor_Areas_excluded)

  excluded_count <- length(unique(excluded_slides$image_id))
  if (excluded_count > 0) {
    cat(paste(c(
      "Found", excluded_count, "slides containing",
      length(Tumor_Areas_excluded$image_id), "tumors that were manually flagged for exclusion."
    )))
    cat("\nThese slides are highlighted in red in the Panel A below and excluded from further analyses.")
    kable(select(Slide_Areas_excluded, "image_id", "animal_id", full_group, "number_of_tumors", "exclude_reason"), caption = "Excluded slides")
  } else {
    cat("No slides were manually flagged for exclusion.")
  }
} else {
  cat("No slides were manually flagged for exclusion. 'Exclude_reason' column not present in Slide Information File.")
}
```

```{r check_for_multiple_slides, message = FALSE, warning = FALSE, class.output="bg-warning"}
multiple_h_e_slides <- Slide_Info %>% get_dupes(animal_id)
dupe_count <- length(unique(multiple_h_e_slides$animal_id))
if (dupe_count > 0) {
  cat(paste(c("Found", dupe_count, "animals with multiple H&E stained slides"), collapse = " "))
  kable(select(multiple_h_e_slides, animal_id:image_id))
} else {
  cat("No animals with multiple H&E slides found in dataset.")
}
```

## Hide {.active}

--------------------------------------------------------------------------------

# Results {.tabset .tabset-fade}

## H&E analysis {.tabset .tabset-fade .tabset-pills}

### Slide level analysis {.tabset .tabset-fade .tabset-pills}

#### Tumor count {.tabset .tabset-fade .tabset-pills}

##### No tumor grading

<a id="graph_001"></a>

```{r graph_001, fig.cap= figure_caption}
# plot tumor counts per slide as dot plot
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    number_of_tumors
  ) 

# no stats for this graph
plot1 <- graph_data %>%
  rowwise() %>%
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  group_by(individual_id) %>%
  mutate(subindividual_count = n()) %>% 
  ungroup() %>%
  ggplot(aes(
    x = individual_id,
    y = number_of_tumors,
    color = full_group,
    group = individual_id,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      "<b>", subindividual_var_label, ": </b>", subindividual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor Count: </b>", number_of_tumors
    )
  ))
plot1 <- plot1 +
  geom_point() + 
    {if (max(plot1$data$subindividual_count) > 1) 
  list(stat_summary(
    fun = mean,
    fun.min = min,
    fun.max = max,
    shape = 3,
    size = 2
  ))
      } +
  scale_color_manual(values = group_colors) +
  ggtitle(
    "Tumor Count",
    paste(
      "per", individual_unit, "by",
      paste_to_text_list(full_grouping_vars_labels)
    )
  ) +
  # make axis labels more descriptive
  labs(x = individual_var_label, y = "Tumor count")

# convert to plotly graph and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  layout(
    width = min(40 * individual_count, 800),
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    margin = list(plotly_margins),
    legend = list(
      groupclick = "togglegroup",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    )
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  {if (max(plot1$data$subindividual_count) > 1) 
  format_plotly_trace(., "scatter", "lines+markers",
    hoverinfo = "y",
    marker = list(opacity = 0.6)
  ) else . }
# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_001_data.csv"), row.names = FALSE)

# add caption to figure
figure_caption <- paste0(
  "Graph 001: Dot plot of tumor counts for each slide in data set by ",
  paste_to_text_list(full_grouping_vars_labels),
  ". Crossbars indicate the mean count for each ",
  individual_unit
)
```


```{r graph_002, fig.cap= figure_caption}
# get data for graph
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id, full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    number_of_tumors
  ) %>%
  group_by(individual_id) %>%
  mutate(
    total_number_of_tumors = sum(number_of_tumors),
    subindividual_count = n()
  ) %>%
  slice(1)

# perform statistical comparisons
graph_formula <- total_number_of_tumors ~ full_group

# {summary_stats,homo_var_violation,homo_var_test,norm_violation,norm_test}
stats_summary <- run_stats_summary(graph_data, graph_formula)
if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}

# plot tumor count distributions by group
plot1 <- graph_data %>%
  rowwise() %>%
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = total_number_of_tumors,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor Count: </b>", total_number_of_tumors
    )
  )) +
  geom_boxplot(width = 0.4, size = 1) +
  # outline bars using colors based on group
  scale_color_manual(values = group_colors) +
  # format graph
  ggtitle(
    "Tumor Count",
    paste("by", paste_to_text_list(full_grouping_vars_labels))
  ) +
  labs(x = full_grouping_label, y = "Tumor count")

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  layout(
    width = min(200 * full_group_count, 800),
    margin = plotly_margins,
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    )
  ) %>%
  format_plotly_trace("box",
    boxpoints = "outliers",
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  )

# output statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

write.csv(graph_data, file.path(path_to_graph_data, "graph_002_data.csv"), row.names = FALSE)

figure_caption <- paste(
  "Graph 002: Box plot of tumor counts within each",
  paste_to_text_list(full_grouping_vars_labels),
  "."
)
```

##### Graded tumors {.tabset .tabset-fade .tabset-pills}

###### Counts

<a id="graph_003"></a>

```{r graph_003, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    slide_number,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade
  ) %>%
  group_by(individual_id) %>%
  mutate(subindividual_count = n_distinct(subindividual_id)) %>%
  group_by(individual_id, tumor_grade) %>%
  mutate(tumor_count_in_individual = n()) %>%
  slice(1)

# no stats to perform for this graph

# plot tumor counts by tumor grade for each slide
plot1 <- graph_data %>%
  rowwise() %>%
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = individual_id,
    y = tumor_count_in_individual,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>Tumor count: </b>", tumor_count_in_individual, "</br>"
    )
  )) +
  geom_col(position = "stack") +
  # fill bars using colors based on area grade
  scale_fill_manual(values = tumor_grade_colors, drop = FALSE) +
  # outline bars using colors based on group
  scale_color_manual(values = group_colors, drop = FALSE) +
  # add descriptive title and subtitle
  ggtitle(
    "Tumor counts",
    paste("by tumor grade per", individual_unit)
  ) +
  # change x axis tick labels to slide id
  labs(x = individual_var_label, y = "Tumor Count")

# covert to plotly and format
ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    width = min(100 * individual_count, 800),
    margin = plotly_margins
  ) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "label")


# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_003_data.csv"), row.names = FALSE)

figure_caption <- paste(
  "Graph 003: Stacked bar graph of tumor counts of each grade from each slide.",
  "The overall tumor grade were assigned based on the highest grade present that makes up ≥ 10% of the tumor's area."
)
```

<a id="graph_004"></a>
```{r graph_004, fig.cap= figure_caption}
# get data for graph
graph_data <- Tumor_Areas %>%
  group_by(full_group) %>%
  mutate(
    individual_count = n_distinct(individual_id),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(total_tumor_count_in_individual = n()) %>%
  slice(1) %>%
  group_by(full_group, tumor_grade) %>%
  mutate(total_tumor_count = sum(total_tumor_count_in_individual)) %>%
  slice(1) %>%
  select(
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    individual_count,
    subindividual_count,
    total_tumor_count
  )

# no stats to perform for this graph

# plot total count of tumor of each grade per group in stacked bar graph
plot2 <- graph_data %>%
  rowwise() %>%
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = total_tumor_count,
    color = full_group,
    fill = tumor_grade,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>", individual_unit, " count: </b>", individual_count, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>Tumor count: </b>", total_tumor_count
    )
  )) +
  geom_bar(stat = "identity", position = "stack", width = 0.6) +
  # fill bars using colors based on area grade
  scale_fill_manual(
    values = tumor_grade_colors,
    labels = tumor_grade_labels
  ) +
  # outline bars using colors based on group
  scale_color_manual(
    values = group_colors,
    labels = full_group_labels
  ) +
  ggtitle(
    "Total tumor count",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) +
  labs(x = full_grouping_label, y = "Tumor Count")

ggplotly_subtitle(plot2, hoverinfo = c("text")) %>%
  layout(
    legend = list(
      orientation = "v",
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    width = min(c(200 * full_group_count, 800)),
    margin = plotly_margins,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    )
  ) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "label")

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_004_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 004:Stacked bar graph of total tumor counts of each grade in each ",
  full_grouping_vars_labels,
  ". The overall tumor grade were assigned based on the highest grade present that makes up ≥ 10% of the tumor's area."
)
```

<a id="graph_005"></a>
```{r graph_005, fig.cap= figure_caption}
# plot average count of tumor of each grade per slide in stacked bar graph
graph_data <- Tumor_Areas %>%
  select(
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    individual_id,
    subindividual_id,
    tumor_grade
  ) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(tumor_count_in_individual = n()) %>%
  group_by(full_group, tumor_grade) %>%
  mutate(
    mean_tumor_count = mean(tumor_count_in_individual),
    individual_count = n_distinct(individual_id),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  slice(1) %>%
  select(
    -individual_id,
    -subindividual_id,
    -tumor_count_in_individual
  )

# no stats for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = mean_tumor_count,
    color = full_group,
    fill = tumor_grade,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>", individual_unit, " count: </b>", individual_count, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor count: </b>", round(mean_tumor_count, digits = 2), "</br>"
    )
  )) +
  geom_col(position = "stack", width = 0.6) +
  scale_fill_manual(
    values = tumor_grade_colors,
    labels = tumor_grade_labels
  ) +
  scale_color_manual(
    values = group_colors,
    labels = full_group_labels
  ) +
  ggtitle(
    "Mean tumor count",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) +
  labs(x = full_grouping_label, y = "Tumor Count")

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  layout(
    legend = list(
      orientation = "v",
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    width = min(200 * full_group_count, 800),
    margin = plotly_margins,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    )
  ) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list)

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_004_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 005: Stacked bar graph of mean tumor count of each grade within each ",
  full_grouping_label,
  ". The overall tumor grades were assigned based on the highest grade present that makes up ≥ 10% of the tumor's area."
)
```

<a id="graph_006"></a>

```{r graph_006, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    individual_id,
    subindividual_id,
    tumor_grade
  ) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(tumor_count_in_individual = n()) %>%
  group_by(full_group, tumor_grade) %>%
  mutate(
    individual_count = n_distinct(individual_id),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  slice(1)

# perform statistics
graph_formula <- tumor_count_in_individual ~ full_group:tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)
if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

# make graph
plot1 <- graph_data %>%
  rowwise() %>%
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = tumor_grade,
    y = tumor_count_in_individual,
    fill = tumor_fill,
    color = full_group,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>", individual_unit, " count: </b>", individual_count, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor count: </b>", round(tumor_count_in_individual, digits = 2), "</br>"
    )
  )) +
  geom_boxplot(
    width = 0.5,
    position = position_dodge(width = 1),
    size = 1
  ) +
  scale_fill_manual(values = alpha(tumor_grade_colors, 0.3)) +
  scale_color_manual(values = group_colors) +
  scale_x_discrete(drop = FALSE, limits = tumor_grade_x_limits) +
  ggtitle(
    "Mean tumor count",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) +
  labs(x = "Tumor Grade", y = "Tumor Count") # make axis label more descriptive

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  layout(
    boxmode = "group",
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    width = min(300 * full_group_count, 800),
    margin = plotly_margins
  ) %>%
  format_plotly_trace("box",
    boxpoints = "outliers",
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_006_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 006: Box plot of tumor counts by grade from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". The overall tumor grades were assigned based on the highest grade present that makes up ≥10% of the tumor's area."
)
```

###### Proportions

<a id="graph_007"></a>
```{r graph_007, fig.cap= figure_caption}
# plot tumor proportions by tumor grade for each slide
graph_data <- Tumor_Areas %>%
  select(
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    individual_id,
    subindividual_id,
    tumor_grade
  ) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(tumor_count_in_individual = n()) %>%
  slice(1) %>%
  group_by(individual_id) %>%
  mutate(
    tumor_proportion_in_individual = round(
      tumor_count_in_individual /
        sum(tumor_count_in_individual),
      digits = 3
    ),
    subindividual_count = n_distinct(subindividual_id)
  )

# no stats needed for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = individual_id,
    y = tumor_proportion_in_individual,
    color = full_group,
    fill = tumor_grade,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor Grade: </b>", tumor_grade, "</br>",
      "<b>Tumor count: </b>", tumor_count_in_individual, "</br>",
      "<b>Proportion of tumors: </b>", tumor_proportion_in_individual
    )
  )) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = tumor_grade_colors, limits = tumor_grade_x_limits) +
  scale_color_manual(values = group_colors) +
  ggtitle(
    "Tumor proportions",
    paste("by tumor grade per", individual_unit)
  ) + # add descriptive title and subtitle
  labs(x = individual_var_label, y = "Proportion of tumors") 

  # convert to plotly graph and format
  ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(100 * individual_count, 800) / full_group_count
      ))
    ),
    width = min(100 * individual_count, 800),
    margin = plotly_margins
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "label")

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_007_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 007: Stacked bar graph of proportion of tumors of each grade within each", individual_unit,
  ". This does not account for differences in tumor number among slides or differences in sizes among individual tumors."
)
```


<a id="graph_008"></a>
```{r graph_008, fig.cap= figure_caption}
# plot average proportion of tumor grades per group in stacked bar graph
graph_data <- Tumor_Areas %>%
  select(
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    individual_id,
    subindividual_id,
    tumor_grade
  ) %>%
  group_by(full_group, tumor_grade) %>%
  mutate(n = n()) %>%
  slice(1) %>%
  group_by(full_group) %>%
  mutate(proportion = round(n / sum(n), 3))

# no stats to perform on this data

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = proportion,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>Proportion: </b>", proportion
    )
  )) +
  geom_col(position = "fill") +
  scale_fill_manual(values = tumor_grade_colors) +
  scale_color_manual(values = group_colors) +
  scale_y_continuous(limits = c(0,1)) + 
  ggtitle(
    "Total tumor proportion",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) +
  labs(x = full_grouping_label, y = "Proportion of tumors")


ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels), collapse = "\n"),
        "</b>"
      ))
    ),
    autosize = F,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    width = min(c(200 * full_group_count, 800)),
    margin = plotly_margins
  ) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list)

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_008_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 008: Grouped bar graph of mean proportion of tumors of each grade by ",
  paste_to_text_list(full_grouping_vars_labels),
  ". This does not account for differences in tumor number among slides or differences in sizes among individual tumors."
)
```

<a id="graph_009"></a>
```{r graph_009, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(full_group,
         all_of(full_grouping_vars),
         all_of(sample_info_vars), 
         individual_id, 
         subindividual_id, 
         tumor_grade) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(tumor_count_in_individual = n()) %>%
  slice(1) %>%
  group_by(individual_id) %>%
  mutate(
    tumor_proportion_in_individual = round(tumor_count_in_individual / sum(tumor_count_in_individual), digits = 3),
    subindividual_count = n_distinct(subindividual_id)
  )

# perform statistics
graph_formula <- remove_lowinfo_terms(graph_data, tumor_proportion_in_individual ~ full_group * tumor_grade)
stats_summary <- run_stats_summary(graph_data, graph_formula)
if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

plot1 <- graph_data %>%
  ggplot(aes(
    x = fct_rev(tumor_grade),
    y = tumor_proportion_in_individual,
    fill = tumor_fill,
    color = full_group
  )) +
  geom_boxplot(
    width = 0.5,
    position = position_dodge(.6),
    size = 1
  ) +
  # fill using defined colors
  scale_fill_manual(
    values = alpha(tumor_grade_colors, 0.3),
    labels = tumor_grade_labels,
    guide = guide_legend(override.aes = list(
      linetype = 0,
      alpha = 1
    ))
  ) +
  scale_color_manual(values = group_colors) +
  scale_y_continuous(limits = c(0,1))+
  scale_x_discrete(drop = FALSE,  limits = tumor_grade_x_limits)+
  ggtitle(
    "Tumor proportion",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) +
  labs(x = "Tumor Grade", y = "Proportion of tumors ")

ggplotly_subtitle(plot1) %>%
  layout(
    boxmode = "group",
    legend = list(
      orientation = "v",
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    width = min(c(300 * full_group_count, 800)),
    margin = plotly_margins
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group") %>%
  format_plotly_trace("box",
    boxpoints = "outliers",
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_009_data.csv"), row.names = FALSE)

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}


figure_caption <- paste0(
  "Graph 009: Box plot of the percentage of tumors of each grade in each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". This does not account for differences in tumor number among slides or differences in sizes among individual tumors."
)
```

<a id="graph_010"></a>

```{r graph_010, fig.cap= figure_caption}
# plot average proportion of tumor grades per slide in pie chart

graph_data <- Tumor_Areas %>%
  group_by(full_group, tumor_grade) %>%
  summarise(n = n()) %>%
  mutate(proportion_of_tumors = n / sum(n))

graph_data <- graph_data %>%
  mutate(
    cs = rev(cumsum(rev(proportion_of_tumors))),
    pos = proportion_of_tumors / 2 + lead(cs, 1),
    pos = if_else(is.na(pos),
      proportion_of_tumors / 2,
      pos
    )
  )

# no statistics for this graph

plot1 <- graph_data %>%
  group_by(full_group, tumor_grade) %>%
  ggplot(aes(
    x = "",
    y = proportion_of_tumors,
    fill = tumor_grade,
    color = full_group
  )) +
  geom_bar(
    stat = "identity",
    width = 1,
    position = "stack"
  ) +
  coord_polar("y", start = 0) +
  facet_wrap("full_group",
    labeller = labeller(full_group = full_group_info_list$full_group)
  ) +
  scale_fill_manual(
    values = tumor_grade_colors,
    labels = tumor_grade_labels
  ) +
  scale_color_manual(
    values = group_colors,
    guide = "none"
  ) +
  geom_label_repel(
    aes(
      y = pos,
      label = sprintf("%0.2f", round(proportion_of_tumors,
        digits = 2
      ))
    ),
    size = 4,
    show.legend = F,
    nudge_x = 1,
    color = "black"
  ) +
  theme_void() + # remove ticks and labels
  ggtitle(
    "Proportion of total tumor count",
    paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    ))
  ) +
  labs(color = full_grouping_label, fill = "Tumor Grade")

# leave this graph as a ggplot. Can't convert to plotly object.
print(plot1)

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_010_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 010: Pie chart of the percentage of tumors of each grade in each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". This same data is presented in the Graph 008."
)
```

#### Tumor burden {.tabset .tabset-fade .tabset-pills}

##### Total tumor area {.tabset .tabset-fade .tabset-pills}

###### No tumor grading

<a id="graph_011"></a>

```{r graph_011, fig.cap= figure_caption}
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    total_tumor_area_in_image,
    exclude_reason
  )

# no stats needed for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  group_by(individual_id) %>%
  mutate(subindividual_count = n()) %>%
  ungroup() %>%
  ggplot(aes(
    x = individual_id,
    y = total_tumor_area_in_image,
    color = full_group,
    group = individual_id,
    text = paste0(
      "</br>",
      "<b>",
      individual_var_label,
      ": </b>",
      individual_id,
      "</br>",
      "<b>",
      subindividual_var_label,
      ": </b>",
      subindividual_id,
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>Total Tumor Area: </b>",
      format(
        round(
          total_tumor_area_in_image,
          0
        ),
        big.mark = ","
      ), " µm<sup>2</sup>"
    )
  ))
plot1 <- plot1 +
  geom_point() + # plot scatter aligned dot plot
  {if (max(plot1$data$subindividual_count) > 1) 
      list(
  stat_summary(
    fun = mean,
    fun.min = min,
    fun.max = max,
    shape = 3,
    size = 2
  ))
      } +
  scale_color_manual(values = group_colors) + # fill bars using colors by group
  scale_y_log10() +
  ggtitle("Total tumor area", paste("per", individual_unit)) +
  labs(
    x = individual_var_label,
    y = "Total tumor area"
  ) # make y-axis label more descriptive


ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  layout(
    width = min(50 * individual_count, 800),
    hoverdistance = 1,
    xaxis = list(tickangle = -90, tickfont = list(size = min(0.8 * min(50 * individual_count, 800) / individual_count, 10))),
    legend = list(title = list(text = paste0("<b>", paste0(c(full_grouping_vars_labels), collapse = "\n"), "</b>"))),
    margin = list(
      l = 50,
      r = 50,
      b = 50,
      t = 50
    )
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  {if (max(plot1$data$subindividual_count) > 1) 
  format_plotly_trace(.,"scatter", "lines+markers",
    hoverinfo = "y",
    marker = list(opacity = 0.6)
  ) else . }


# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_011_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 011: Dot plot of total tumor area for each slide in data set by",
  paste_to_text_list(c("tumor grade", full_grouping_vars_labels)), "Points/labels in red indicate slidesthat were manually flagged for exclusion (see 'Excluded Slides' table in [Data Filtering])."
)
```

<a id="graph_012"></a>

```{r graph_012, fig.cap= figure_caption}
# plot tumor area distributions by grouping var
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group, 
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    total_tumor_area_in_image
  ) %>%
  group_by(individual_id) %>%
  mutate(
    total_tumor_area_in_individual = sum(total_tumor_area_in_image),
    log10_total_tumor_area_in_individual = log10(total_tumor_area_in_individual)
         ) %>%
  select(-total_tumor_area_in_image) %>%
  slice(1) %>%
  group_by(full_group)

# perform statistics
graph_formula <- total_tumor_area_in_individual ~ full_group
graph_note <- ""
if (test_log_normalization(graph_data,graph_formula)){
  graph_formula <- log10_total_tumor_area_in_individual ~ full_group
  graph_yvar <- "log10_total_tumor_area_in_individual"
  graph_note <- "Data were log10 transformed prior to statistical analysis."
}
stats_summary <- run_stats_summary(graph_data, graph_formula)
if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}

# plot total tumor area distribution by group
plot1 <- graph_data %>%
  ggplot(aes(
    x = full_group,
    y = total_tumor_area_in_individual,
    color = full_group
  )) +
  geom_boxplot(width = 0.4, size = 1) +
  scale_y_continuous(trans = "log10") +
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  ggtitle("Total tumor area", paste("by", paste_to_text_list(full_grouping_vars_labels))) +
  # guides(color = guide_legend(title = group_var_label)) +
  labs(
    x = full_grouping_label,
    y = "Tumor area (sq. micron)"
  )

# convert to plotly object and format
ggplotly_subtitle(plot1) %>%
  layout(
    width = min(200 * full_group_count, 800),
    margin = plotly_margins,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    legend = list(title = list(text = paste0("<b>", paste0(c(full_grouping_vars_labels), collapse = "\n"), "</b>")))
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  format_plotly_trace(
    "box", 
    boxpoints = "outliers", 
    pointpos = 0.0, 
    marker = list(
      opacity = 0.6, 
      size = 4, 
      line = list(color = "rgba(0,0,0,0)")
      )
    )



# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}


# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_012_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 012: Box plot of mean total tumor area from each ", individual_unit, " by ",
  paste_to_text_list(full_grouping_vars_labels), ". ", graph_note
)
```

<a id="graph_013"></a>
```{r graph_013, fig.cap= figure_caption}
# manipulate Slide_Areas table to plot area grades in stacked bar graph
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group, 
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    grade1_area_in_image,
    grade2_area_in_image,
    grade3_area_in_image,
    grade4_area_in_image,
    grade5_area_in_image
  ) %>%
  pivot_longer(
    c(
      grade1_area_in_image,
      grade2_area_in_image,
      grade3_area_in_image,
      grade4_area_in_image,
      grade5_area_in_image
    ),
    values_to = "grade_area_in_image",
    names_to = "area_grade"
  ) %>%
  mutate(area_grade = factor(area_grade,
    levels = c(
      "grade5_area_in_image",
      "grade4_area_in_image",
      "grade3_area_in_image",
      "grade2_area_in_image",
      "grade1_area_in_image"
    ),
    labels = c("5","4", "3", "2", "1")
  )) %>%
  group_by(full_group, individual_id, area_grade) %>%
  mutate(subindividual_count = n_distinct(subindividual_id)) %>%
  group_by(full_group, individual_id, area_grade) %>%
  mutate(total_grade_area = sum(grade_area_in_image)) %>%
  slice(1) %>%
  select(-subindividual_id)

individual_count <- n_distinct(graph_data$individual_id)
# no stats needed for this graph

# plot tumor areas of each grade for each slide as stacked bar graph
plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = individual_id,
    y = total_grade_area,
    fill = area_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Area grade: </b>", area_grade, "</br>",
      "<b>Tumor area: </b>", format(
        round(
          total_grade_area,
          0
        ),
        big.mark = ","
      ), " µm<sup>2</sup>"
    )
  )) +
  geom_bar(position = "stack", stat = "identity") + # plot stacked bar graph
  scale_fill_manual(values = tumor_grade_colors, drop = FALSE, limits = tumor_grade_x_limits) + # fill bars using colors based on area grade
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + # rotate x-axis text 45
  ggtitle("Tumor Area", paste("of each grade per", individual_unit)) + # add descriptive title and subtitle
  labs(x = individual_var_label, y = "Tumor area (sq. micron)") # make y-axis label more descriptive

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "label", verbose = T) %>%
  layout(
    legend = list(
      orientation = "v",
      size = 30,
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0("<b>", paste0(c(full_grouping_vars_labels, "Area Grade"), collapse = "\n"), "</b>"),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(tickangle = -90, tickfont = list(size = min(10, 0.8 * min(50 * individual_count, 800) / individual_count))),
    width = min(c(200 * individual_count, 800)),
    margin = list(plotly_margins)
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_013_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 013: Stacked bar graph showing the total tumor area of each grade within each ", individual_unit,
  ", with bar colors showing the contribution of areas of each tumor grade and bar outlines showing ", full_grouping_label, ". "
)
```
###### Graded tumors

<a id="graph_014"></a>
```{r graph_014, fig.cap= figure_caption}
# plot tumor areas of each grade for each slide as stacked bar graph
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group, all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    total_tumor_area
  ) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(
    subindividual_count = n_distinct(subindividual_id),
    total_tumor_grade_area_in_slide = sum(total_tumor_area),
    number_of_grade_tumors_in_individual = n()
  ) %>%
  slice(1) %>%
  select(-subindividual_id)

# no stats needed for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = individual_id,
    y = total_tumor_grade_area_in_slide,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor area: </b>", format(
        round(
          total_tumor_grade_area_in_slide,
          0
        ),
        big.mark = ","
      ), " µm<sup>2</sup>", "</br>",
      "<b>Tumor count: </b>", number_of_grade_tumors_in_individual
    )
  )) +
  geom_bar(position = "stack", stat = "identity") + # plot stacked bar graph
  scale_fill_manual(values = tumor_grade_colors) + # fill bars using colors based on area grade
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  theme(
    legend.position = "bottom", legend.box = "vertical",
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
  ) + # rotate x-axis text 45
  ggtitle("Tumor Area", paste("of each grade per", individual_unit)) + # add descriptive title and subtitle
  labs(x = individual_var_label, y = "Tumor area (sq. micron)") # make y-axis label more descriptive

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      orientation = "v",
      size = 30,
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0("<b>", paste0(c(full_grouping_vars_labels, "Tumor Grade"), collapse = "\n"), "</b>"),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(tickangle = -90, tickfont = list(size = min(10, 0.8 * min(50 * individual_count, 800) / individual_count))),
    width = min(c(200 * individual_count, 800)),
    margin = list(plotly_margins)
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_014_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 014: Stacked bar graph showing the total area of tumors of each grade within each ",
  individual_unit, 
  ". Tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area.",
  " This representation is not equivalent to the \"tumor area of each grade\"; this graph shows the \"total area of tumors of each grade\", which includes all of the area within a tumor regardless of the areas respective grade."
)
```

<a id="graph_015"></a>

```{r graph_015, fig.cap= figure_caption}
# try to perform stats comparisons between groups

graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group, all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    total_tumor_area
  ) %>%
  mutate(tumor_grade = fct_rev(tumor_grade)) %>%
  group_by(full_group, individual_id, tumor_grade) %>%
  mutate(
    total_graded_tumor_area = sum(total_tumor_area),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  slice(1) %>%
  ungroup()


# perform statistics
graph_formula <- total_graded_tumor_area ~ full_group * tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

plot1 <- graph_data %>% ggplot(
  aes(
    x = tumor_grade,
    y = total_graded_tumor_area,
    fill = tumor_fill,
    color = full_group
    )
  ) +
  geom_boxplot(
    position = position_dodge2(width = .9, preserve = "single"),
    width = 0.75,
    size = 1
  ) +
  # fill using defined colors
  scale_fill_manual(
    values = tumor_grade_colors,
    labels = tumor_grade_labels,
    guide = guide_legend(override.aes = list(linetype = 0, alpha = 1))
  ) +
  scale_y_log10(expand = expansion(mult = c(0,.2))) + #make y-axis log scale
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  ggtitle(
    "Mean total tumor area",
    paste("by", paste_to_text_list(c("tumor grade", full_grouping_vars_labels)))
  ) +
  labs(x = "Tumor Grade", y = "Tumor Area (sq. micron)")

ggplotly_subtitle(plot1) %>%
  layout(
    boxmode = "group",
    legend = list(
      orientation = "v",
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>", paste0(full_grouping_vars_labels,
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = FALSE,
    width = min(300 * full_group_count, 800),
    margin = plotly_margins
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group") %>%
  format_plotly_trace(
    "box",
    boxpoints = "outliers",
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  )

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

# write graph data to file
write.csv(
  graph_data,
  file.path(path_to_graph_data, "graph_015_data.csv"),
  row.names = FALSE)

figure_caption <- paste0(
  "Graph 015: Box plot of mean total tumor area of tumors of each grade from ",
  individual_unit, " by ", paste_to_text_list(full_grouping_vars_labels), 
  ". Tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area. This representation is not equivalent to the \"tumor area of each grade\"; this graph shows the \"total area of tumors of each grade\", which includes all of the area within a tumor regardless of the areas respective grade."
  )
```

##### Proportion of tumor area {.tabset .tabset-fade .tabset-pills}

###### No tumor grading

<a id="graph_016"></a>

```{r graph_016, fig.cap= figure_caption}
# manipulate Slide_Areas table to plot proportion of area grades in stacked bar graph
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    grade1_area_in_image,
    grade2_area_in_image,
    grade3_area_in_image,
    grade4_area_in_image,
    grade5_area_in_image,
    total_tumor_area_in_image
  ) %>%
  group_by(full_group, individual_id) %>%
  mutate(
    subindividual_count = n_distinct(subindividual_id),
    total_tumor_grade_area_in_individual = sum(total_tumor_area_in_image),
    grade1_area_in_individual = sum(grade1_area_in_image),
    grade2_area_in_individual = sum(grade2_area_in_image),
    grade3_area_in_individual = sum(grade3_area_in_image),
    grade4_area_in_individual = sum(grade4_area_in_image),
    grade5_area_in_individual = sum(grade5_area_in_image)
  ) %>%
  slice(1) %>%
  select(
    -subindividual_id,
    -grade1_area_in_image,
    -grade2_area_in_image,
    -grade3_area_in_image,
    -grade4_area_in_image,
    -grade5_area_in_image,
    -total_tumor_area_in_image
  ) %>%
  mutate(
    grade1_proportion_in_individual = grade1_area_in_individual / total_tumor_grade_area_in_individual,
    grade2_proportion_in_individual = grade2_area_in_individual / total_tumor_grade_area_in_individual,
    grade3_proportion_in_individual = grade3_area_in_individual / total_tumor_grade_area_in_individual,
    grade4_proportion_in_individual = grade4_area_in_individual / total_tumor_grade_area_in_individual,
    grade5_proportion_in_individual = grade5_area_in_individual / total_tumor_grade_area_in_individual
  )

# no stats for this graph

# plot proportion area grades per slide in stacked bar graph
plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  # pivot data to plot each grade stacked within an individual
  pivot_longer(
    c(
      grade1_proportion_in_individual,
      grade2_proportion_in_individual,
      grade3_proportion_in_individual,
      grade4_proportion_in_individual,
      grade5_proportion_in_individual
    ),
    values_to = "grade_proportion_in_individual",
    names_to = "area_grade"
  ) %>%
  mutate(across("area_grade", \(x) str_replace(x, "grade", ""))) %>%
  mutate(across("area_grade", \(x) str_replace(x, "_proportion_in_individual", ""))) %>%
  # rearrange graph so grade 4 is on top
  mutate(area_grade = factor(
    area_grade,
    levels = c(
      "5",
      "4",
      "3",
      "2",
      "1"
      )
    )
  ) %>%
  ggplot(aes(
    x = individual_id,
    y = grade_proportion_in_individual,
    fill = area_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Area grade: </b>", rev(tumor_grade_labels), "</br>",
      "<b>Proportion: </b>", round(grade_proportion_in_individual, digits = 3)
      )
    )
  ) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = tumor_grade_colors) +
  scale_color_manual(values = group_colors) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Proportion of tumor area", "of each grade per slide") +
  labs(x = individual_var_label, y = "Proportion of tumor area")

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0(
          "<b>",
          paste0(
            c(full_grouping_vars_labels, "Tumor Grade"), 
                 collapse = "\n"
          ), 
          "</b>"
        ),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(
      tickangle = -90,
      tickfont = list(
        size = min(
          10,
          0.8 * min(50 * individual_count, 800) / individual_count
        )
      )
    ),
    width = min(200 * individual_count, 800),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_016_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 016: Stacked bar graph of the proportion of tumor area present within each",
  individual_unit,
  ". This does not account for differences in tumor number or tumor burden among the analyzed", 
  individual_unit, "."
  )
```



<a id="graph_017"></a>
```{r graph_017, fig.cap= figure_caption}
# plot average proportion of area grades per individual in stacked bar graph
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group, 
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    grade1_area_in_image, grade2_area_in_image,
    grade3_area_in_image, grade4_area_in_image,
    grade5_area_in_image,
    total_tumor_area_in_image
  ) %>%
  group_by(full_group, individual_id) %>%
  mutate(
    subindividual_count = n_distinct(subindividual_id),
    total_tumor_grade_area_in_individual = sum(total_tumor_area_in_image,na.rm = TRUE),
    grade1_area_in_individual = sum(grade1_area_in_image,na.rm = TRUE),
    grade2_area_in_individual = sum(grade2_area_in_image,na.rm = TRUE),
    grade3_area_in_individual = sum(grade3_area_in_image,na.rm = TRUE),
    grade4_area_in_individual = sum(grade4_area_in_image,na.rm = TRUE),
    grade5_area_in_individual = sum(grade5_area_in_image,na.rm = TRUE)
  ) %>%
  slice(1) %>%
  select(
    -subindividual_id, -grade1_area_in_image, -grade2_area_in_image,
    -grade3_area_in_image, -grade4_area_in_image, -grade5_area_in_image, -total_tumor_area_in_image
  ) %>%
  mutate(
    grade1_proportion_in_individual = grade1_area_in_individual / total_tumor_grade_area_in_individual,
    grade2_proportion_in_individual = grade2_area_in_individual / total_tumor_grade_area_in_individual,
    grade3_proportion_in_individual = grade3_area_in_individual / total_tumor_grade_area_in_individual,
    grade4_proportion_in_individual = grade4_area_in_individual / total_tumor_grade_area_in_individual,
    grade5_proportion_in_individual = grade5_area_in_individual / total_tumor_grade_area_in_individual
  ) %>%
  mutate(grouping_labels = paste0("<b>", full_grouping_vars_labels, ": </b>",
    across(all_of(full_grouping_vars)), "</br>",
    collapse = ""
  )) %>%
  # pivot data to plot each grade stacked within an individual
  pivot_longer(
    c(
      grade1_proportion_in_individual,
      grade2_proportion_in_individual,
      grade3_proportion_in_individual,
      grade4_proportion_in_individual,
      grade5_proportion_in_individual
    ),
    values_to = "grade_proportion_in_individual",
    names_to = "area_grade"
  ) %>%
  mutate(grade_proportion_in_individual = replace_na(grade_proportion_in_individual,0)) %>%
  mutate(across("area_grade", \(x) str_replace(x, "grade", ""))) %>%
  mutate(across("area_grade", \(x) str_replace(x, "_proportion_in_individual", "")))

# perform statistics
graph_formula <- grade_proportion_in_individual ~ full_group:area_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

plot1 <- graph_data %>%
  ggplot(aes(
    x = area_grade,
    y = grade_proportion_in_individual,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Area grade: </b>", rev(tumor_grade_labels), "</br>",
      "<b>Proportion: </b>", round(grade_proportion_in_individual, digits = 3)
    )
  )) +
  geom_boxplot(
    position = position_dodge2(width = .9, preserve = "single"),
    width = 0.75,
    size = 1
  ) +
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  ggtitle(
    "Proportion of total tumor area",
    paste("by", paste_to_text_list(c("tumor grade", full_grouping_vars_labels)))
  ) +
  labs(x = "Tumor Grade", y = "Proportion of tumor area") # make axis label more descriptive

ggplotly_subtitle(plot1) %>%
  layout(
    boxmode = "group",
    legend = list(
      orientation = "v",
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0("<b>", full_grouping_label, "</b>"))
    ),
    autosize = F,
    width = min(300 * full_group_count, 800),
    margin = plotly_margins
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  format_plotly_trace("box", boxpoints = "outliers", pointpos = 0.0, marker = list(opacity = 0.6, size = 4, line = list(color = "rgba(0,0,0,0)")))

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

# write graph data to file
write.csv(
  graph_data, 
  file.path(path_to_graph_data, "graph_017_data.csv"), 
  row.names = FALSE
  )

figure_caption <- paste0(
  "Graph 017: Box plot of the proportion of total tumor area for each tumor grade within each", 
  paste_to_text_list(full_grouping_vars_labels), 
  ". This does not account for differences in tumor number or tumor burden among the analyzed ", 
  individual_unit
  )
```


###### Graded Tumors

<a id="graph_018"></a>

```{r graph_018, fig.cap= figure_caption}
# plot proportion of tumor areas of each grade for each slide as stacked bar graph
graph_data <- Tumor_Areas %>%
  select(individual_id,
         subindividual_id, 
         full_group, 
         all_of(full_grouping_vars),
         all_of(sample_info_vars),
         tumor_grade, 
         total_tumor_area) %>%
  group_by(individual_id) %>%
  mutate(total_tumor_area_in_individual = sum(total_tumor_area)) %>%
  group_by(individual_id, tumor_grade) %>%
  mutate(
    total_area_of_graded_tumors = sum(total_tumor_area),
    proportion_of_total_tumor_area = total_area_of_graded_tumors / total_tumor_area_in_individual,
    subindividual_count = n_distinct(subindividual_id),
    number_of_grade_tumors_in_individual = n()
  ) %>%
  select(-total_tumor_area, -subindividual_id) %>%
  slice(1)

# no stats for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = individual_id,
    y = proportion_of_total_tumor_area,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>Tumor count: </b>", number_of_grade_tumors_in_individual, "</br>",
      "<b>Total area: </b>", format(
        round(
          total_area_of_graded_tumors,
          0
        ),
        big.mark = ","
      ), " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total tumor area: </b>", round(proportion_of_total_tumor_area, 3)
    )
  )) +
  geom_bar(position = "fill", stat = "identity") + # plot stacked bar graph
  scale_fill_manual(values = tumor_grade_colors) + # fill bars using colors based on area grade
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  theme(
    legend.position = "bottom", legend.box = "vertical",
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
  ) + # rotate x-axis text 45
  ggtitle(
    "Proportion of total tumor area",
    paste("by overall tumor grade per", individual_unit)
  ) + # add descriptive title and subtitle
  labs(x = individual_var_label, y = "Proportion of tumor area") # make y-axis label more descriptive

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0("<b>", paste0(c(full_grouping_vars_labels, "Tumor Grade"), collapse = "\n"), "</b>"),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(tickangle = -90, tickfont = list(size = min(10, 0.8 * min(50 * individual_count, 800) / individual_count))),
    width = min(200 * individual_count, 800),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_018_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 018: Stacked bar graph showing the proportion of the total tumor area in each ", 
                         individual_unit, " from tumors of each grade within each ", individual_unit, 
                         ". Tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area.",
                         " **This representation is not equivalent to the 'total area of each tumor grade'; this graph shows the 'total area of tumors of each grade', which includes all of the area within a tumor regardless of the areas respective grade. (i.e., the area of each tumor is considered to be the same as the overall tumor grade)**",
                         " *This does not account for differences in tumor number or tumor burden among the analyzed ",
                         individual_unit, "s.*")
```

<a id="graph_019"></a>

```{r graph_019, fig.cap= figure_caption}
# plot proportion of tumor areas of each grade for each slide as stacked bar graph

graph_data <- Tumor_Areas %>%
  select(individual_id, subindividual_id, full_group, all_of(full_grouping_vars),all_of(sample_info_vars), tumor_grade, total_tumor_area) %>%
  group_by(full_group, across(full_grouping_vars), tumor_grade) %>%
  mutate(
    total_graded_tumor_area = sum(total_tumor_area),
    tumor_count = n(),
    individual_count = n_distinct(individual_id),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  slice(1) %>%
  group_by(full_group) %>%
  mutate(total_tumor_area = sum(total_graded_tumor_area)) %>%
  group_by(full_group, tumor_grade) %>%
  mutate(graded_proportion_of_total_tumor_area = total_graded_tumor_area / total_tumor_area)

# no stats for this figure

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = graded_proportion_of_total_tumor_area,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>", individual_unit, " count: </b>", individual_count, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Tumor grade: </b>", tumor_grade, "</br>",
      "<b>Tumor count: </b>", tumor_count, "</br>",
      "<b>Total area: </b>", format(
        round(
          total_graded_tumor_area,
          0
        ),
        big.mark = ","
      ), " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total tumor area: </b>", round(graded_proportion_of_total_tumor_area, 3)
    )
  )) +
  stat_summary(fun = "mean", geom = "bar", position = "fill", width = 0.4) +
  scale_fill_manual(values = tumor_grade_colors) + # fill bars using colors based on area grade
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_x_discrete(labels = full_group_labels) + # change x axis tick labels to slide id
  ggtitle("Proportion of tumor area", paste("by overall tumor grade per", full_grouping_vars_labels)) + # add descriptive title and subtitle
  labs(x = full_grouping_label, y = "Tumor area (sq. micron)") # make y-axis label more descriptive

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0("<b>", paste0(c(full_grouping_vars_labels, "Tumor Grade"), collapse = "\n"), "</b>"),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    width = min(200 * full_group_count, 800),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_019_data.csv"), row.names = FALSE)


figure_caption <- paste0(
  "Graph 019: Stacked bar graph showing the proportion of the total tumor area in each ", 
  paste_to_text_list(full_grouping_vars_labels), " from tumors of each grade. Tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area. **This representation is not equivalent to the 'total area of each tumor grade'; this graph shows the 'total area of tumors of each grade', which includes all of the area within a tumor
regardless of the areas respective grade. (i.e., the area of each tumor is
considered to be the same as the overall tumor grade)** *This does not account
for variablity in tumor number or tumor burden among the analyzed ", 
individual_unit, "s.*")
```

<a id="graph_020"></a>

```{r graph_020, fig.cap= figure_caption}
# try to perform stats comparisons between groups
graph_data <- Tumor_Areas %>%
  select(full_group, all_of(full_grouping_vars),all_of(sample_info_vars), individual_id, subindividual_id, tumor_grade, total_tumor_area) %>%
  group_by(individual_id) %>%
  mutate(
    total_tumor_area_in_individual = sum(total_tumor_area),
    subindividual_count_in_individual = n_distinct(subindividual_id),
  ) %>%
  select(-subindividual_id) %>%
  group_by(individual_id, tumor_grade) %>%
  mutate(
    tumor_count_in_individual = n(),
    total_graded_tumor_area = sum(total_tumor_area),
    graded_proportion_of_total_tumor_area = total_graded_tumor_area / total_tumor_area_in_individual
  ) %>%
  select(-total_tumor_area) %>%
  slice(1)

# perform statistics
graph_formula <- graded_proportion_of_total_tumor_area ~ full_group:tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = tumor_grade,
    y = graded_proportion_of_total_tumor_area,
    fill = tumor_fill,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b> Tumor Grade: </b>", tumor_grade, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count_in_individual, "</br>",
      "<b>Tumor Count: </b>", tumor_count_in_individual, "</br>",
      "<b>Total graded tumor area: </b>", format(round(total_graded_tumor_area, 0), big.mark = ","), " µm<sup>2</sup>", "</br>",
      "<b>Total tumor area: </b>", format(round(total_tumor_area_in_individual, 0), big.mark = ","), " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>", round(graded_proportion_of_total_tumor_area, 3)
    )
  )) +
  geom_boxplot() +
  # fill using defined colors
  scale_fill_manual(
    values = tumor_grade_colors,
    labels = tumor_grade_labels,
    guide = guide_legend(override.aes = list(linetype = 0, alpha = 1))
  ) +
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_x_discrete(limits = tumor_grade_x_limits) +
  ggtitle("Proportion of total tumor area", paste("from tumors of each grade in each", full_grouping_label)) + # add descriptive title and subtitle
  labs(
    x = "Tumor Grade", y = "Proportion of total tumor area", # make axis label more descriptive
    fill = "Tumor Grade", color = full_grouping_label
  )

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  format_plotly_trace("box", boxpoints = "outliers", pointpos = 0.0, marker = list(opacity = 0.6, size = 4, line = list(color = "rgba(0,0,0,0)"))) %>%
  layout(
    width = min(200 * full_group_count, 800),
    boxmode = "group",
    margin = plotly_margins,
    legend = list(
      title = list(text = paste0("<b>", paste0(c(full_grouping_vars_labels), collapse = "\n"), "</b>")),
      side = "top"
    )
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_020_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 020: Box plot of the proportion of total tumor area for each tumor grade within each", paste_to_text_list(full_grouping_vars_labels), ". This does not account for differences in tumor number or tumor burden among the analyzed ", individual_unit)
```

##### Proportion of lung area {.tabset .tabset-fade .tabset-pills}

###### No tumor grading

<a id="graph_021"></a>

```{r graph_021, fig.cap= figure_caption}
graph_data <- Slide_Areas %>%
  select(
    individual_id, subindividual_id, full_group, all_of(full_grouping_vars),
    all_of(sample_info_vars),
    grade1_area_in_image, grade2_area_in_image, grade3_area_in_image, 
    grade4_area_in_image, grade5_area_in_image,
    total_tissue_area_in_image
  ) %>%
  group_by(individual_id) %>%
  mutate(
    grade1_proportion_of_lung_area = sum(grade1_area_in_image) / sum(total_tissue_area_in_image),
    grade2_proportion_of_lung_area = sum(grade2_area_in_image) / sum(total_tissue_area_in_image),
    grade3_proportion_of_lung_area = sum(grade3_area_in_image) / sum(total_tissue_area_in_image),
    grade4_proportion_of_lung_area = sum(grade4_area_in_image) / sum(total_tissue_area_in_image),
    grade5_proportion_of_lung_area = sum(grade5_area_in_image) / sum(total_tissue_area_in_image),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  select(-subindividual_id, -grade1_area_in_image, -grade2_area_in_image, -grade3_area_in_image, -grade4_area_in_image, -grade5_area_in_image) %>%
  slice(1)

# no stats for this graph

# plot proportion area grades per slide in stacked bar graph
plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  pivot_longer(c(grade1_proportion_of_lung_area, grade2_proportion_of_lung_area, grade3_proportion_of_lung_area, grade4_proportion_of_lung_area, grade5_proportion_of_lung_area),
    names_to = "area_grade",
    values_to = "proportion_of_lung_area"
  ) %>%
  mutate(grade_area_in_lung_area = proportion_of_lung_area * total_tissue_area_in_image) %>%
  # format 'area_grade' to be numbers only
  mutate(across("area_grade", \(x) str_replace(x, "grade", ""))) %>%
  mutate(across("area_grade", \(x) str_replace(x, "_proportion_of_lung_area", ""))) %>%
  # rearrange graph so grade 4 is on top
  mutate(area_grade = factor(area_grade,
    levels = c(
      "5",
      "4",
      "3",
      "2",
      "1"
    )
  )) %>%
  ggplot(aes(
    x = individual_id,
    y = proportion_of_lung_area,
    fill = area_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_unit, " ID: </b>", individual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Area grade: </b>", area_grade, "</br>",
      "<b>Total grade area: </b>", format(round(grade_area_in_lung_area, 0), big.mark = ","), " µm<sup>2</sup>", "</br>",
      "<b>Total lung area: </b>", format(round(total_tissue_area_in_image, 0), big.mark = ","), " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>", round(proportion_of_lung_area, 3)
    )
  )) +
  geom_bar(position = "stack", stat = "identity") +
  # scale_fill_manual(values=c("#00ff00", "#0000ff", "#ffff00", "#ff0000")) + #fill bars: green, blue, yellow, red
  scale_fill_manual(values = tumor_grade_colors) + # fill bars using colors based on area grade
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_y_continuous(limits = c(0,1)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + # rotate x-axis text 45˚
  ggtitle("Proportion of lung area", "of each tumor grade per slide") + # add descriptive title and subtitle
  labs(x = "Slide ID", y = "Proportion of lung area") # make y-axis label more descriptive

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0("<b>", paste0(c(full_grouping_vars_labels, "Tumor Grade"), collapse = "\n"), "</b>"),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(tickangle = -90, tickfont = list(size = min(10, 0.8 * min(50 * individual_count, 800) / individual_count))),
    width = min(c(100 * individual_count, 800)),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_021_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 021: Stacked bar graph of the proportion of lung area of each tumor grade in each ", individual_unit, ". This comparison accounts for differences in tissue sizes across slides.")
```


<a id="graph_022"></a>

```{r graph_022, fig.cap= figure_caption}
graph_data <- Slide_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    grade1_area_in_image,
    grade2_area_in_image,
    grade3_area_in_image,
    grade4_area_in_image,
    grade5_area_in_image,
    total_tissue_area_in_image
  ) %>%
  group_by(full_group) %>%
  mutate(
    grade1_proportion_of_lung_area = sum(grade1_area_in_image) / sum(total_tissue_area_in_image),
    grade2_proportion_of_lung_area = sum(grade2_area_in_image) / sum(total_tissue_area_in_image),
    grade3_proportion_of_lung_area = sum(grade3_area_in_image) / sum(total_tissue_area_in_image),
    grade4_proportion_of_lung_area = sum(grade4_area_in_image) / sum(total_tissue_area_in_image),
    grade5_proportion_of_lung_area = sum(grade5_area_in_image) / sum(total_tissue_area_in_image),
    number_of_individuals = n_distinct(individual_id),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  select(
    -individual_id,
    -subindividual_id,
    -grade1_area_in_image,
    -grade2_area_in_image,
    -grade3_area_in_image,
    -grade4_area_in_image,
    -grade5_area_in_image
  ) %>%
  slice(1)

# no stats for this graph

# plot proportion area grades per slide in stacked bar graph
plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  pivot_longer(
    c(
      grade1_proportion_of_lung_area,
      grade2_proportion_of_lung_area,
      grade3_proportion_of_lung_area,
      grade4_proportion_of_lung_area,
      grade5_proportion_of_lung_area
    ),
    names_to = "area_grade",
    values_to = "proportion_of_lung_area"
  ) %>%
  mutate(grade_area_in_lung_area = proportion_of_lung_area * total_tissue_area_in_image) %>%
  # format 'area_grade' to be numbers only
  mutate(across("area_grade", \(x) str_replace(x, "grade", ""))) %>%
  mutate(across("area_grade", \(x) str_replace(x, "_proportion_of_lung_area", ""))) %>%
  # rearrange graph so grade 4 is on top
  mutate(area_grade = factor(area_grade,
    levels = c(
      "5",
      "4",
      "3",
      "2",
      "1"
    )
  )) %>%
  ggplot(aes(
    x = full_group,
    y = proportion_of_lung_area,
    fill = area_grade,
    color = full_group,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>", individual_unit, " count: </b>", number_of_individuals, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      "<b>Area grade: </b>", area_grade, "</br>",
      "<b>Total grade area: </b>",
      format(round(grade_area_in_lung_area, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Total lung area: </b>",
      format(round(total_tissue_area_in_image, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>",
      round(proportion_of_lung_area, 3)
    )
  )) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = tumor_grade_colors) +
  scale_color_manual(values = group_colors) +
  scale_y_continuous(limits = c(0,1)) +
  ggtitle(
    "Proportion of lung area by",
    paste_to_text_list(c("tumor grade", full_grouping_vars_labels))
  ) +
  labs(x = full_grouping_label, y = "Proportion of lung area")

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0(
          "<b>",
          paste0(
            c(
              full_grouping_vars_labels,
              "Tumor Grade"
            ),
            collapse = "\n"
          ),
          "</b>"
        ),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    width = min(c(200 * full_group_count, 800)),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_022_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 022: Stacked bar graph of the proportion of lung area comprised of each tumor grade from each ", 
                         paste_to_text_list(full_grouping_vars_labels), ".")
```


<a id="graph_023"></a>

```{r graph_023, fig.cap= figure_caption}
graph_data <- Slide_Areas %>%
  select(individual_id, subindividual_id, full_group, all_of(full_grouping_vars),all_of(sample_info_vars),
         number_of_tumors, total_tumor_area_in_image, total_tissue_area_in_image) %>%
  mutate(total_tumor_proportion_of_lung_area = total_tumor_area_in_image / total_tissue_area_in_image)

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  group_by(individual_id) %>%
  mutate(subindividual_count = n()) %>%
  ungroup() %>%
  ggplot(aes(
    x = individual_id,
    y = total_tumor_proportion_of_lung_area,
    color = full_group,
    group = individual_id,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      "<b>", subindividual_var_label, ": </b>", subindividual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor Count: </b>", number_of_tumors, "</br>",
      "<b>Total tumor area: </b>", format(round(total_tumor_area_in_image, 0), big.mark = ","), " µm<sup>2</sup>", "</br>",
      "<b>Total lung area: </b>", format(round(total_tissue_area_in_image, 0), big.mark = ","), " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>", round(total_tumor_proportion_of_lung_area, 3)
    )
  )) +
  geom_point() + # plot scatter aligned dot plot
  {if (max(graph_data$subindividual_count) > 1) 
      list(
  stat_summary(
    fun = mean,
    fun.min = min,
    fun.max = max,
    shape = 3,
    size = 2
  ))
      } +
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_y_continuous(limits = c(0,1)) +
  ggtitle("Tumor proportion of lung area", paste("by", individual_unit)) + # add descriptive title and subtitle
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + # rotate x-axis text 45˚
  labs(x = individual_var_label, y = "Proportion of lung area") # make axis labels more descriptive

# convert to plotly graph and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  layout(
    width = min(40 * individual_count, 800),
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    margin = list(
      l = 50,
      r = 50,
      b = 50,
      t = 50
    ),
    legend = list(title = list(
      text = paste0("<b>", paste0(c(full_grouping_vars_labels), collapse = "\n"), "</b>"),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  {if (max(graph_data$subindividual_count) > 1) 
  format_plotly_trace("scatter", "lines+markers",
    hoverinfo = "y",
    marker = list(opacity = 0.6)
  ) else . }

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_023_data.csv"), row.names = FALSE)

# add caption to figure
figure_caption <- paste0(
  "Graph 023: Dot plot of tumor counts for each slide in data set by", 
  paste_to_text_list(full_grouping_vars_labels), 
  ". Points are labeled with their ", 
  individual_var_label, "."
  )
```

<a id="graph_024"></a>

```{r graph_024, fig.cap= figure_caption}
graph_data <- Slide_Areas %>%
  group_by(individual_id) %>%
  select(individual_id, subindividual_id, full_group, all_of(full_grouping_vars),
         all_of(sample_info_vars),total_tumor_area_in_image, total_tissue_area_in_image, number_of_tumors) %>%
  mutate(
    total_tumor_proportion_of_lung_area = sum(total_tumor_area_in_image) / sum(total_tissue_area_in_image),
    total_tumor_count = sum(number_of_tumors),
    subindividual_count = n_distinct(subindividual_id)
  ) %>%
  select(-subindividual_id) %>%
  slice(1)

# perform statistics
graph_formula <- total_tumor_proportion_of_lung_area ~ full_group
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = total_tumor_proportion_of_lung_area,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Tumor Count: </b>", total_tumor_count, "</br>",
      "<b>Total tumor area: </b>", format(round(total_tumor_area_in_image, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Total lung area: </b>", format(round(total_tissue_area_in_image, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>",
      round(total_tumor_proportion_of_lung_area, 3)
    )
  )) +
  geom_boxplot() +
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_y_continuous(limits = c(0,1)) +
  ggtitle(
    "Tumor proportion of lung area",
    paste("by", paste_to_text_list(full_grouping_vars_labels))
  ) + # add descriptive title and subtitle
  labs(x = full_grouping_label, y = "Proportion of lung area") # make axis labels more descriptive

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  layout(
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    width = min(200 * full_group_count, 800),
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  format_plotly_trace("box",
    boxpoints = "outliers",
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  )

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_024_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 024: Box plot of the proportion of lung area each tumor grade occupies in each ",
  paste_to_text_list(full_grouping_vars_labels),
  "."
)
```

###### Graded Tumors

<a id="graph_025"></a>

```{r graph_025, fig.cap= figure_caption}
# plot proportion of tumor areas of each grade for each slide as stacked bar graph
graph_data <- Tumor_Areas %>%
  group_by(subindividual_id) %>%
  mutate(total_tumor_count_in_subindividual = n()) %>%
  group_by(subindividual_id, tumor_grade) %>%
  mutate(
    total_area_of_graded_tumors = sum(total_tumor_area),
    graded_tumor_count_in_subindividual = n()
  ) %>%
  slice(1) %>%
  left_join(Slide_Areas,
    by = c("subindividual_id" = "subindividual_id"),
    suffix = c("", ".y")
  ) %>%
  group_by(individual_id) %>%
  mutate(
    total_tumor_count_in_individual = sum(total_tumor_count_in_subindividual)
  ) %>%
  group_by(individual_id, tumor_grade) %>%
  mutate(
    subindividual_count = n(),
    total_tissue_area_in_individual = sum(total_tissue_area_in_image),
     total_graded_tumor_count_in_individual = sum(graded_tumor_count_in_subindividual),
     total_graded_tumor_area_in_individual = sum(total_area_of_graded_tumors),
     total_grade_tumor_proportion_of_lung_area = total_graded_tumor_area_in_individual /
      total_tissue_area_in_individual) %>% 
  ungroup() %>%
  select(
    individual_id, full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    subindividual_count,
    total_graded_tumor_count_in_individual,
    total_area_of_graded_tumors,
    total_tumor_count_in_individual,
    total_tissue_area_in_individual,
    total_grade_tumor_proportion_of_lung_area
  )

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = individual_id,
    y = total_grade_tumor_proportion_of_lung_area,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      "<b>", subindividual_unit, " count: </b>", subindividual_count, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Total Tumor count: </b>", total_tumor_count_in_individual, "</br>",
      "<b>Grade ", tumor_grade, " Tumor count: </b>", total_graded_tumor_count_in_individual, "</br>",
      "<b>Total Grade ", tumor_grade, " area: </b>",
      format(round(total_area_of_graded_tumors, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Total lung area: </b>",
      format(round(total_tissue_area_in_individual, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>",
      round(total_grade_tumor_proportion_of_lung_area, 3)
    )
  )) +
  geom_bar(position = "stack", stat = "identity") + # plot stacked bar graph
  scale_fill_manual(values = tumor_grade_colors) + # fill bars using colors based on area grade
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_y_continuous(limits = c(0,1)) +
  ggtitle(
    "Proportion of lung area",
    paste0("by overall tumor grade per ", individual_unit)
  ) + # add descriptive title and subtitle
  labs(x = individual_var_label, y = "Proportion of lung area") # make y-axis label more descriptive


ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(text = paste0(
        "<b>",
        paste0(
          c(full_grouping_vars_labels,"Tumor Grade"),
          collapse = "\n"
        ),
        "</b>"
      ))
    ),
    autosize = F,
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    width = min(100 * individual_count, 800),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_025_data.csv"), row.names = FALSE)

figure_caption <- "Graph 025: Stacked bar graph showing the proportion of lung area from tumors of each grade within each slide. Tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area. **This representation is not equivalent to the 'total area of each tumor grade'; this graph shows the 'total area of tumors of each grade', which includes all of the area within a tumor regardless of the areas respective grade. (i.e., the area of each tumor is considered to be the same as the overall tumor grade)**"
```



<a id="graph_026"></a>

```{r graph_026, fig.cap= figure_caption}
# plot proportion of tumor areas of each grade for each group as stacked bar graph
graph_data <- Tumor_Areas %>%
  group_by(subindividual_id) %>%
  mutate(total_tumor_count_in_subindividual = n()) %>%
  group_by(subindividual_id, tumor_grade) %>%
  mutate(
    total_area_of_graded_tumors_in_subindividual = sum(total_tumor_area),
    graded_tumor_count_in_subindividual = n()
  ) %>%
  slice(1) %>%
  left_join(Slide_Areas,
    by = c("subindividual_id" = "subindividual_id"),
    suffix = c("", ".y")
  ) %>%
  group_by(individual_id) %>%
  mutate(
    total_tumor_count_in_individual = sum(total_tumor_count_in_subindividual)
  ) %>%
  group_by(individual_id, tumor_grade) %>%
  mutate(
    subindividual_count = n_distinct(subindividual_id),
    total_area_of_graded_tumors_in_individual = sum(total_area_of_graded_tumors_in_subindividual),
    total_graded_tumor_count_in_individual = sum(graded_tumor_count_in_subindividual),
    total_tissue_area_in_individual = sum(total_tissue_area_in_image),
    total_grade_tumor_proportion_of_lung_area = total_area_of_graded_tumors_in_individual /
      total_tissue_area_in_individual) %>%
  slice(1) %>%
  select(
    individual_id, full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade, subindividual_count,
    total_graded_tumor_count_in_individual,
    total_area_of_graded_tumors_in_individual,
    total_tumor_count_in_individual,
    total_tissue_area_in_individual,
    total_grade_tumor_proportion_of_lung_area
  ) %>%
  group_by(full_group, tumor_grade) %>%
  mutate(
    number_of_individuals = n_distinct(individual_id),
    number_of_subindividuals = sum(subindividual_count),
    graded_tumor_count_in_group = sum(total_graded_tumor_count_in_individual),
    total_area_of_graded_tumors_in_group = sum(total_area_of_graded_tumors_in_individual),
    total_tumor_count_in_group = sum(total_tumor_count_in_individual),
    total_tissue_area_in_group = sum(total_tissue_area_in_individual),
    total_grade_tumor_proportion_of_lung_area_in_group = total_area_of_graded_tumors_in_group / 
      total_tissue_area_in_group
  ) %>%
  slice(1) %>%
  select(
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade, number_of_individuals,
    number_of_subindividuals,
    graded_tumor_count_in_group,
    total_tumor_count_in_group,
    total_area_of_graded_tumors_in_group,
    total_tissue_area_in_group,
    total_grade_tumor_proportion_of_lung_area_in_group
  )

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  ggplot(aes(
    x = full_group,
    y = total_grade_tumor_proportion_of_lung_area_in_group,
    fill = tumor_grade,
    color = full_group,
    text = paste0(
      "</br>",
      grouping_labels, sample_info_labels,
      "<b>", individual_unit, " count: </b>", number_of_individuals, "</br>",
      "<b>", subindividual_unit, " count: </b>", number_of_subindividuals, "</br>",
      "<b>Total Tumor count: </b>", total_tumor_count_in_group, "</br>",
      "<b>Grade ", tumor_grade, " Tumor count: </b>",
      graded_tumor_count_in_group, "</br>",
      "<b>Total Grade ", tumor_grade, " area: </b>",
      format(round(total_area_of_graded_tumors_in_group, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Total lung area: </b>",
      format(round(total_tissue_area_in_group, 0),
        big.mark = ","
      ),
      " µm<sup>2</sup>", "</br>",
      "<b>Proportion of total lung area: </b>",
      round(total_grade_tumor_proportion_of_lung_area_in_group, 3)
    )
  )) +
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_manual(values = tumor_grade_colors) +
  scale_color_manual(values = group_colors) +
  scale_y_continuous(limits = c(0,1)) +
  ggtitle(
    "Proportion of total lung area",
    paste0("by ", paste_to_text_list(
      "overall tumor grade",
      full_grouping_vars_labels
    ))
  ) +
  labs(x = full_grouping_label, y = "Proportion of lung area")

ggplotly_subtitle(plot1, hoverinfo = c("text")) %>%
  format_plotly_trace("bar", width = 0.7) %>%
  format_plotly_legend("full_group", full_group_grade_info_list) %>%
  layout(
    legend = list(
      groupclick = "toggleitem",
      traceorder = "grouped",
      title = list(
        text = paste0(
          "<b>",
          paste0(c(full_grouping_vars_labels, "Tumor Grade"),
            collapse = "\n"
          ),
          "</b>"
        ),
        side = "top"
      )
    ),
    autosize = F,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    width = min(200 * full_group_count, 800),
    margin = plotly_margins
  )

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_026_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 026: Stacked bar graph showing the proportion of total tumor area from tumors of each grade within each ", paste_to_text_list(full_grouping_vars_labels), ". The overall tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area. **This representation is not equivalent to the 'total area of each tumor grade'; this graph shows the 'total area of tumors of each grade', which includes all of the area within a tumor regardless of the areas respective grade (i.e., the area of each tumor is considered to be the same as the overall tumor grade)**.")
```



<a id="graph_027"></a>

```{r graph_027, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  group_by(subindividual_id) %>%
  mutate(total_tumor_count_in_subindividual = n()) %>%
  group_by(subindividual_id, tumor_grade) %>%
  mutate(
    total_area_of_graded_tumors_in_subindividual = sum(total_tumor_area),
    graded_tumor_count_in_subindividual = n()
  ) %>%
  slice(1) %>%
  left_join(Slide_Areas,
    by = c("subindividual_id" = "subindividual_id"),
    suffix = c("", ".y")
  ) %>%
  group_by(individual_id) %>%
  mutate(
    total_tumor_count_in_individual = sum(total_tumor_count_in_subindividual)
  ) %>%
  group_by(individual_id, tumor_grade) %>%
  mutate(
    subindividual_count = n_distinct(subindividual_id),
    total_area_of_graded_tumors_in_individual = sum(total_area_of_graded_tumors_in_subindividual),
    total_graded_tumor_count_in_individual = sum(graded_tumor_count_in_subindividual),
    total_tissue_area_in_individual = sum(total_tissue_area_in_image),
    total_grade_tumor_proportion_of_lung_area = total_area_of_graded_tumors_in_individual /
      total_tissue_area_in_individual) %>%
  slice(1) %>%
  select(
    individual_id, full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade, subindividual_count,
    total_graded_tumor_count_in_individual,
    total_area_of_graded_tumors_in_individual,
    total_tumor_count_in_individual,
    total_tissue_area_in_individual,
    total_grade_tumor_proportion_of_lung_area
  ) 

# perform statistics
graph_formula <- total_grade_tumor_proportion_of_lung_area ~ full_group:tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_individuals)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

plot1 <- graph_data %>%
  mutate(tumor_grade = fct_rev(tumor_grade)) %>%
  ggplot(aes(
    x = tumor_grade,
    y = total_grade_tumor_proportion_of_lung_area,
    fill = tumor_fill,
    color = full_group
  )) +
  geom_boxplot() +
  # fill using defined colors
  scale_fill_manual(values = tumor_grade_colors) +
  scale_color_manual(values = group_colors) +
  scale_y_continuous(limits = c(0,1)) +
  ggtitle(
    "Proportion of lung area",
    paste(
      "from tumors of each grade in each",
      paste_to_text_list(full_grouping_vars_labels)
    )
  ) +
  labs(x = "Tumor Grade", y = "Proportion of lung area")

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  format_plotly_trace("box",
    boxpoints = "outliers",
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  layout(
    width = min(200 * full_group_count, 800),
    boxmode = "group",
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_027_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 027: Box plot showing the proportion of total tumor area from tumors of each grade within each ", paste_to_text_list(full_grouping_vars_labels), ". The overall tumor grade was assigned based on the highest grade present that makes up ≥ 10% of the tumor's area. **This representation is not equivalent to the 'total area of each tumor grade'; this graph shows the 'total area of tumors of each grade', which includes all of the area within a tumor regardless of the areas respective grade (i.e., the area of each tumor is considered to be the same as the overall tumor grade)**.")
```

### Individual tumor analysis {.tabset .tabset-fade .tabset-pills}

#### Tumor area {.tabset .tabset-fade .tabset-pills}

##### No tumor grading

<a id="graph_028"></a>

```{r graph_028, fig.cap= figure_caption}
# plot distribution of individual tumor areas for each slide
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    total_tumor_area
  )

# no stats for this graph

plot1 <- graph_data %>%
  ggplot(aes(
    x = individual_id,
    y = total_tumor_area,
    fill = full_group
  )) +
  geom_violin(position = "dodge", alpha = 0.5) +
  geom_boxplot() +
  scale_y_continuous(trans = "log10") +
  scale_fill_manual(values = group_colors) +
  ggtitle(
    "Individual tumor areas",
    paste("by", individual_unit)
  ) +
  labs(x = individual_var_label, y = "Tumor area (sq. micron)")

ggplotly_subtitle(plot1) %>%
  layout(
    width = min(200 * individual_count, 800),
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_trace("box",
    width = 0.1,
    boxpoints = FALSE
  ) %>%
  format_plotly_trace("scatter", "lines",
    hoverinfo = "skip"
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group")

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_028_data.csv"), row.names = FALSE)

figure_caption <- paste0("Graph 028: Violin plot of individual tumor areas from each ", individual_unit, ".")
```

<a id="graph_029"></a>

```{r graph_029, fig.cap= figure_caption}
# plot distribution  of individual tumor areas for each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    total_tumor_area
  )

# perform statistics
graph_formula <- total_tumor_area ~ full_group
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_tumors)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}


plot1 <- graph_data %>%
  ggplot(aes(
    x = full_group,
    y = total_tumor_area,
    fill = full_group
  )) +
  geom_violin(position = "dodge", alpha = 0.5) +
  geom_boxplot() + # add boxplot to middle of violin plot
  scale_y_continuous(trans = "log10") + # convert y-axis to log 10 scale
  scale_fill_manual(values = group_colors) +
  ggtitle(
    "Individual tumor areas",
    paste("by", paste_to_text_list(full_grouping_vars_labels))
  ) + # add descriptive title and subtitle
  labs(x = full_grouping_label, y = "Tumor area (sq. micron)") # make axis labels more descriptive

ggplotly_subtitle(plot1) %>%
  layout(
    width = min(200 * full_group_count, 800),
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_trace("box",
    width = 0.1,
    boxpoints = FALSE
  ) %>%
  format_plotly_trace("scatter", "lines",
    hoverinfo = "skip"
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group")

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_029_data.csv"), row.names = FALSE)

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}


figure_caption <- paste0("Graph 029: Violin plot of individual tumor sizes from each ", paste_to_text_list(full_grouping_vars_labels), ".")
```



##### Graded tumors

<a id="graph_030"></a>

```{r graph_030, fig.cap= figure_caption}
# plot distribution  of individual tumor areas for each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    total_tumor_area
  )

# perform statistics
graph_formula <- total_tumor_area ~ full_group:tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_tumors)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

# plot individual tumor size distribution by tumor grade and group
plot1 <- Tumor_Areas %>%
  ggplot(aes(
    x = fct_rev(tumor_grade), # make tumor grades increase left to right
    y = total_tumor_area,
    color = fct_rev(full_group),
    fill = tumor_fill
  )) +
  geom_boxplot() +
  scale_fill_manual(values = tumor_grade_colors) +
  scale_color_manual(values = group_colors) +
  ggtitle(
    "Individual tumor areas",
    paste("by", paste_to_text_list("tumor grade", full_grouping_vars_labels))
  ) +
  scale_y_log10(expand = expansion(mult = c(0, .2))) +
  labs(x = "Tumor Grade", y = "Tumor Area (sq. micron)")


ggplotly_subtitle(plot1) %>%
  format_plotly_trace("box",
    boxpoints = FALSE,
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  layout(
    width = min(200 * full_group_count, 800),
    boxmode = "group",
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_030_data.csv"), row.names = FALSE)

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

figure_caption <- paste0(
  "Graph 030: Box plot of individual tumor sizes within each tumor grade from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". Plots show min to max as whiskers with median and IQR shown as boxes"
  )
```


### Intratumor heterogeneity {.tabset .tabset-fade .tabset-pills}

#### Shannon Diversity Index

<a id="graph_031"></a>

```{r graph_031, fig.cap= figure_caption}
# plot distribution of individual tumor heterogeneity for each slide
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    shannon_diversity_index
  ) %>%
  group_by(subindividual_id) %>%
  mutate(median_sdi = median(shannon_diversity_index)) %>%
  slice(1)

# no stats for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  group_by(individual_id) %>%
  mutate(subindividual_count = n()) %>%
  ungroup() %>%
  ggplot(aes(
    x = individual_id,
    y = median_sdi,
    color = full_group,
    group = individual_id,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      "<b>", subindividual_var_label, ": </b>", subindividual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Median SDI: </b>", median_sdi
    )
  )) +
  geom_point() +
  {if (max(graph_data$subindividual_count) > 1) 
      list(
  stat_summary(
    fun = mean,
    fun.min = min,
    fun.max = max,
    shape = 3,
    size = 2
  ))
      } +
  ggtitle(
    "Median individual tumor heterogeneity (SDI)",
    paste("in each", individual_unit)
  ) +
  scale_color_manual(values = group_colors) +
  labs(
    x = individual_var_label, 
    y = "Shannon Diversity Index"
  )


# convert to plotly graph and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  layout(
    width = min(80 * individual_count, 800),
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>%
  {if (max(graph_data$subindividual_count) > 1) 
  format_plotly_trace("scatter", "lines+markers",
    hoverinfo = "y",
    marker = list(opacity = 0.6)
  ) else . }


# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_031_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 031: Dot plot of median Shannon Diversity Index ($SDI$) of individual tumors from each ",
  individual_unit,
  ". An $SDI = 0$ indicates only one grade is present within an individual tumor.",
  " The values in this graph may be close to $0$ due to the presence of large numbers of small, homogeneous tumors."
  )
```

<a id="graph_032"></a>

```{r graph_032, fig.cap= figure_caption}
# plot distribution  of individual tumor heterogeneity for each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    shannon_diversity_index
  )

#downsample data randomly and adjust alpha values for plotting
downssampled_graph_data <- graph_data %>% 
  group_by(full_group) %>%
  slice_sample(n = 5000)

plot1 <- downssampled_graph_data %>% 
  ggplot(aes(
    x = full_group,
    y = shannon_diversity_index,
    color = full_group,
  )) +
  geom_point(
    position = position_jitter(width = 0.4),
    size = 1,
    alpha = 0.3
  ) +
  ggtitle(
    "Individual tumor heterogeneity (SDI)",
    paste("by", paste_to_text_list(full_grouping_vars_labels))
  ) +
  scale_color_manual(values = group_colors) +
  scale_y_continuous(breaks = c(0.0, 0.5, 0.7, 1.0, 1.4)) +
  scale_x_discrete(labels = present_full_group_labels$multiline)+
  theme(
    axis.text.x = element_text(size = 6),
    plot.caption = element_text(
      hjust = 1,
      face = "italic"
    )
  )+
  guides(colour = guide_legend(override.aes = list(
    size = 3,
    alpha = 1
  ))) +
  labs(
    x = full_grouping_label, 
    y = "Shannon Diversity Index", 
    color = paste0(full_grouping_vars_labels, collapse = "\n"),
    caption = paste0(
      "Each dot represents an individual tumor.\n",
      "Groups with > 5000 tumors are randomly sampled."
    )
  )

print(plot1)

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_032_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 032: Dot plot of median Shannon Diversity Index ($SDI$) of individual tumors from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". An $SDI = 0$ indicates only one grade is present within an individual tumor.",
  "Groups with > 5000 tumors are randomly sampled."
)
```

<a id="graph_033"></a>

```{r graph_033, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    shannon_diversity_index
  )

# perform statistics
graph_formula <- shannon_diversity_index ~ full_group
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_tumors)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}

# plot Shannon's Diversity Index by tumor grade in each group
plot1 <- graph_data %>%
  ggplot(aes(
    x = full_group,
    y = shannon_diversity_index,
    color = full_group
  )) +
  geom_boxplot() +
  scale_color_manual(values = group_colors) +
  scale_fill_manual(values = tumor_grade_colors) +
  ggtitle(
    "Intratumor heterogeneity (SDI)",
    paste("by", paste_to_text_list(
      full_grouping_vars_labels
    ))
  ) + # add descriptive title and subtitle
  labs(x = full_grouping_label, y = "Shannon Diversity Index")

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  format_plotly_trace("box",
    boxpoints = FALSE,
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  layout(
    width = min(200 * full_group_count, 800),
    margin = plotly_margins,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

write.csv(graph_data, file.path(path_to_graph_data, "graph_033_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 033: Box plot of Shannon's diversity index of individual tumors from each ",
  paste_to_text_list(full_grouping_vars_labels), 
  ". An $SDI = 0$ indicates only one grade is present within an individual tumor.",
  "Plots show min to max as whiskers with median and IQR shown as boxes.")
```

<a id="graph_034"></a>
```{r graph_034, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    shannon_diversity_index
  )

# perform statistics
graph_formula <- shannon_diversity_index ~ full_group:tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_tumors)
  posthoc_test <- run_posthoc_test(omni_test, full_group_tumor_grade_comparisons)
}

# plot Shannon's Diversity Index by tumor grade in each group
plot1 <- graph_data %>%
  mutate(tumor_grade = fct_rev(tumor_grade)) %>%
  ggplot(aes(
    x = tumor_grade,
    y = shannon_diversity_index,
    color = full_group,
    fill = tumor_fill
  )) +
  geom_boxplot() +
  scale_color_manual(values = group_colors) +
  scale_fill_manual(values = tumor_grade_colors) +
  ggtitle(
    "Intratumor heterogeneity (SDI)",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) + # add descriptive title and subtitle
  labs(x = "Tumor Grade", y = "Shannon Diversity Index")

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  format_plotly_trace("box",
    boxpoints = FALSE,
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  layout(
    width = min(200 * full_group_count, 800),
    boxmode = "group",
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

write.csv(graph_data, file.path(path_to_graph_data, "graph_034_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 034: Box plot of Shannon's diversity index of individual tumors of each grade from each ",
  paste_to_text_list(full_grouping_vars_labels), 
  ". An $SDI = 0$ indicates only one grade is present within an individual tumor.",
  "$SDI$ is expected to increase with the overall grade of individual tumors. ",
  "Plots show min to max as whiskers with median and IQR shown as boxes.")
```

<a id="graph_035"></a>

```{r graph_035, fig.cap= figure_caption}
# plot Shannon's Diversity Index by tumor size in each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_uid,
    tumor_grade,
    total_tumor_area,
    shannon_diversity_index
  )

plot1 <- graph_data %>%
  ggplot(aes(
    x = total_tumor_area,
    y = shannon_diversity_index,
    color = tumor_grade
  )) +
  geom_point(alpha = 0.3) +
  scale_color_manual(values = tumor_grade_colors) +
  scale_x_log10() +
  facet_wrap("full_group") +
  ggtitle(
    "Individual tumor intratumor heterogeneity (SDI) vs tumor size ",
    paste("by", paste_to_text_list(c("tumor grade", full_grouping_vars_labels)))
  ) +
  guides(colour = guide_legend(override.aes = list(
    size = 3,
    alpha = 1
  ))) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(
    x = "Tumor Area (sq. micron)",
    y = "Shannon Diversity Index",
    color = "Tumor Grade"
  )

print(plot1)

write.csv(graph_data, file.path(path_to_graph_data, "graph_035_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 035: Scatter plot of Shannon's Diversity Index ($SDI$) against tumor area for individual tumors from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". An $SDI = 0$ indicates only one grade is present within an individual tumor."
  )
```



#### Shannon Equitability Index

<a id="graph_036"></a>

```{r graph_036, fig.cap= figure_caption}
# plot distribution  of individual tumor heterogeneity for each slide
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    shannon_equitability_index
  ) %>%
  group_by(subindividual_id) %>%
  mutate(median_sei = median(shannon_equitability_index)) %>%
  slice(1)

# no stats for this graph

plot1 <- graph_data %>%
  rowwise() %>% 
  make_formatted_labels(full_grouping_vars,full_grouping_vars_labels,"grouping_labels") %>%
  make_formatted_labels(sample_info_vars,sample_info_vars_labels,"sample_info_labels") %>%
  group_by(individual_id) %>%
  mutate(subindividual_count = n()) %>%
  ungroup() %>%
  ggplot(aes(
    x = individual_id,
    y = median_sei,
    color = full_group,
    group = individual_id,
    text = paste0(
      "</br>",
      "<b>", individual_var_label, ": </b>", individual_id, "</br>",
      "<b>", subindividual_var_label, ": </b>", subindividual_id, "</br>",
      grouping_labels, sample_info_labels,
      "<b>Median SEI: </b>", median_sei
    )
  )) +
  geom_point() +
  {if (max(graph_data$subindividual_count) > 1) 
      list(
  stat_summary(
    fun = mean,
    fun.min = min,
    fun.max = max,
    shape = 3,
    size = 2
  ))
      } +
  ggtitle(
    "Median individual tumor heterogeneity (SEI)",
    paste("by", individual_unit)
  ) +
  scale_color_manual(values = group_colors) +
  labs(x = individual_var_label, y = "Shannon Equitability Index")


# convert to plotly graph and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  layout(
    width = min(80 * individual_count, 800),
    xaxis = list(
      tickangle = -90,
      tickfont = list(size = min(
        10,
        0.8 * min(50 * individual_count, 800) / individual_count
      ))
    ),
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_info_list, "full_group") %>% 
  {if (max(graph_data$subindividual_count) > 1) 
  format_plotly_trace("scatter", "lines+markers",
    hoverinfo = "y",
    marker = list(opacity = 0.6)
  ) else . }

# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_036_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 036: Dot plot of median Shannon Equitability Index ($SEI$) of individual tumors from each ",
  individual_unit,
  ". An $SEI = 0$ indicates only one grade is present within an individual tumor.",
  " The maximum possible $SEI = 1$ occurs when all grades present occur in equal proportion.",
  " The values in this graph may be close to $0$ due to the presence of large numbers of small, homogeneous tumors."
  )
```

<a id="graph_037"></a>

```{r graph_037, fig.cap= figure_caption}
# plot distribution  of individual tumor heterogeneity for each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    shannon_equitability_index
  )

#downsample data randomly and adjust alpha values for plotting
downssampled_graph_data <- graph_data %>% 
  group_by(full_group) %>%
  slice_sample(n = 5000)

plot1 <- downssampled_graph_data %>%
  ggplot(aes(
    x = full_group,
    y = shannon_equitability_index,
    color = full_group,
  )) +
  geom_point(
    position = position_jitter(),
    size = 1,
    alpha = 0.3
  ) +
  ggtitle(
    "Individual tumor heterogeneity (SEI)",
    paste("by", paste_to_text_list(full_grouping_vars_labels))
  ) +
  scale_color_manual(values = group_colors) +
  scale_x_discrete(labels = present_full_group_labels$multiline) +
  guides(colour = guide_legend(override.aes = list(
    size = 3,
    alpha = 1
  ))) +
  theme(
    axis.text.x = element_text(size = 6),
    plot.caption = element_text(
      hjust = 1,
      face = "italic"
    )
  ) +
  labs(
    x = full_grouping_label, y = "Shannon Diversity Index",
    color = paste0(c(full_grouping_vars_labels), collapse = "\n"),
    caption = paste0(
      "Each dot represents an individual tumor.\n",
      "Groups with > 5000 tumors are randomly sampled."
    )
  )

print(plot1)
# write graph data to file
write.csv(graph_data, file.path(path_to_graph_data, "graph_037_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 037: Dot plot of theShannon Equitability Index ($SEI$) of individual tumors from each ",
  full_grouping_label,
  ". An $SEI = 0$ indicates only one grade is present within an individual tumor.",
  "The maximum possible $SEI = 1$ occurs when all grades present occur in equal proportion. ",
  "Groups with > 5000 tumors are randomly sampled."
  )
```

<a id ="graph_038"></a>
```{r graph_038, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    shannon_equitability_index
  )

# perform statistics
graph_formula <- shannon_equitability_index ~ full_group
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_tumors)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}

# plot Shannon's Diversity Index by tumor grade in each group
plot1 <- graph_data %>%
  ggplot(aes(
    x = full_group,
    y = shannon_equitability_index,
    color = full_group
  )) +
  geom_boxplot() +
  scale_color_manual(values = group_colors) +
  scale_fill_manual(values = tumor_grade_colors) +
  ggtitle(
    "Intratumor heterogeneity (SDI)",
    paste("by", paste_to_text_list(
      full_grouping_vars_labels
    ))
  ) + # add descriptive title and subtitle
  labs(x = full_grouping_label, y = "Shannon Equitability Index")

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  format_plotly_trace("box",
    boxpoints = FALSE,
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  layout(
    width = min(200 * full_group_count, 800),
    margin = plotly_margins,
    xaxis = list(
      tickmode = "array",
      tickvals = 1:length(present_full_group_labels$label),
      ticktext = present_full_group_labels$multiline
    ),
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "full_group")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

write.csv(graph_data, file.path(path_to_graph_data, "graph_038_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 038: Box plot of Shannon's Equitability Index of individual tumors from each ",
  paste_to_text_list(full_grouping_vars_labels), 
  ". An $SEI = 0$ indicates only one grade is present within an individual tumor.",
" The maximum possible $SEI = 1$ occurs when all grades present occur in equal proportion.",
  "Plots show min to max as whiskers with median and IQR shown as boxes.")
```

<a id="graph_039"></a>

```{r graph_039, fig.cap= figure_caption}
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_grade,
    shannon_equitability_index
  )

# perform statistics
graph_formula <- shannon_equitability_index ~ full_group:tumor_grade
stats_summary <- run_stats_summary(graph_data, graph_formula)

if (!skip_stats) {
  omni_test <- run_omnibus_test(stats_summary, useParametric = parametric_test_tumors)
  posthoc_test <- run_posthoc_test(omni_test, full_group_comparisons)
}

# plot Shannon's Diversity Index by tumor grade in each group
plot1 <- graph_data %>%
  mutate(tumor_grade = fct_rev(tumor_grade)) %>%
  ggplot(aes(
    x = tumor_grade,
    y = shannon_equitability_index,
    color = full_group,
    fill = tumor_fill
  )) +
  geom_boxplot() +
  scale_color_manual(values = group_colors) + # outline bars using colors based on group
  scale_fill_manual(values = tumor_grade_colors) +
  ggtitle(
    "Intratumor heterogeneity (SEI)",
    paste("by", paste_to_text_list("tumor grade", full_grouping_vars_labels))
  ) +
  labs(x = "Tumor Grade", y = "Shannon Equitability Index")

# convert to plotly object and format
ggplotly_subtitle(plot1, hoverinfo = "text") %>%
  format_plotly_trace("box",
    boxpoints = FALSE,
    pointpos = 0.0,
    marker = list(
      opacity = 0.6,
      size = 4,
      line = list(color = "rgba(0,0,0,0)")
    )
  ) %>%
  layout(
    width = min(200 * full_group_count, 800),
    boxmode = "group",
    margin = plotly_margins,
    legend = list(title = list(
      text = paste0(
        "<b>",
        paste0(c(full_grouping_vars_labels),
          collapse = "\n"
        ),
        "</b>"
      ),
      side = "top"
    ))
  ) %>%
  format_plotly_legend("full_group", full_group_grade_info_list, "label")

# print statistics
if (!skip_stats) {
  print_statistics(stats_summary, omni_test, posthoc_test)
} else {
  print_statistics(stats_summary)
}

write.csv(graph_data, file.path(path_to_graph_data, "graph_039_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 039: Box plot of Shannon's Equitability Index ($SEI$) of individual tumors of each grade from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". An $SEI = 0$ indicates only one grade is present within an individual tumor.",
  " The maximum possible $SEI = 1$ occurs when all grades present occur in equal proportion.",
  " $SEI$ is not necessarily expected to increase with the overall grade of individual tumors. ",
  "Plots show min to max as whiskers with median and IQR shown as boxes."
  )
```

<a id="graph_040"></a>

```{r graph_040, fig.cap= figure_caption}
# plot Shannon's Equitability Index by tumor size in each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_uid,
    tumor_grade,
    total_tumor_area,
    shannon_equitability_index
  )

plot1 <- graph_data %>%
  ggplot(aes(
    x = total_tumor_area,
    y = shannon_equitability_index,
    color = tumor_grade
  )) +
  geom_point(alpha = 0.3) +
  scale_color_manual(
    values = tumor_grade_colors, # colors based on tumor grade
    labels = tumor_grade_labels,
  ) +
  scale_x_log10() +
  facet_wrap("full_group") +
  ggtitle(
    "Individual tumor intratumor heterogeneity (SDI) vs size ",
    paste("by", paste_to_text_list(c(
      "tumor grade",
      full_grouping_vars_labels
    )))
  ) +
  guides(colour = guide_legend(override.aes = list(
    size = 3,
    alpha = 1
  ))) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(
    x = "Tumor Area (sq. micron)",
    y = "Shannon Diversity Index",
    color = "Tumor Grade"
  )

print(plot1)

write.csv(graph_data, file.path(path_to_graph_data, "graph_040_data.csv"), row.names = FALSE)

figure_caption <- paste0(
  "Graph 040: Scatter plot of Shannon's Equitability Index ($SEI$) against tumor area for individual tumors from each "
  , paste_to_text_list(full_grouping_vars_labels), 
  ". An $SEI = 0$ indicates only one grade is present within an individual tumor.",
  " The maximum possible $SEI = 1$ occurs when all grades present occur in equal proportion."
  )
```

#### Heterogeneity Graph

<a id="graph_041"></a>

```{r graph_041, fig.cap= figure_caption}
heterogeneity_plot_dim <- c(8, 3)
```

```{r,  message = FALSE, fig.dim= heterogeneity_plot_dim, fig.cap=figure_caption}
# plot intratumor heterogeneity graphs
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_uid,
    tumor_grade,
    grade1_percentage,
    grade2_percentage,
    grade3_percentage,
    grade4_percentage,
    grade5_percentage
  ) %>%
  arrange(
    desc(tumor_grade),
    desc(grade1_percentage),
    desc(grade2_percentage),
    desc(grade3_percentage),
    desc(grade4_percentage),
    grade5_percentage
  )

graph_data$tumor_uid <- factor(Tumor_Areas$tumor_uid, levels = Tumor_Areas$tumor_uid)

downsample_method = "range" # "random" or "range"
downsample_size = 5000

heterogeneity_plots_list <- list()
# iterate over each stain and generate plot
fg_number <- 0
for (fg in present_full_group_labels$label) {
  fg_number <- fg_number + 1

  temp_graph_data <- graph_data %>%
    filter(full_group == fg)
  
  if (downsample_method == "random" && nrow(temp_graph_data) > downsample_size) {
    downsample_method_description = paste(
      "Groups with >", downsample_size,
      "tumors are randomly sampled."
    )
    temp_graph_data <- slice_sample(temp_graph_data, n = downsample_size)
  } else if (downsample_method == "range" && nrow(temp_graph_data) > downsample_size) {
    downsample_index_step = ceiling(nrow(temp_graph_data) / downsample_size)
    downsample_method_description = paste(
       "Groups with >", downsample_size,
       "tumors were evenly sampled after ordering."
    )
    temp_graph_data <- temp_graph_data %>% 
      filter(row_number() %% downsample_index_step == 1)
  } else {
    downsample_method_description = ""
  }
  
  plot_temp <- temp_graph_data %>%
    pivot_longer(
      c(
        grade1_percentage,
        grade2_percentage,
        grade3_percentage,
        grade4_percentage,
        grade5_percentage
      ),
      values_to = "area_grade_percentage",
      names_to = "area_grade"
    ) %>%
  mutate(across("area_grade", \(x) str_replace(x, "grade", ""))) %>%
  mutate(across("area_grade", \(x) str_replace(x, "_percentage", ""))) %>%
  mutate(area_grade = factor(area_grade,
      levels = c(
        "5",
        "4",
        "3",
        "2",
        "1"
      )
    )) %>%
    ggplot(aes(x = tumor_uid)) +
    geom_col(
      position = "fill",
      width = 1,
      aes(
        y = area_grade_percentage,
        fill = area_grade
      )
    ) +
    # plot tumor grade as dot. values misbehave (Grade 4 becomes Grade 1), correct with math
    geom_point(
      stat = "identity",
      size = .1,
      aes(
        x = tumor_uid,
        y = abs((as.numeric(tumor_grade) - (count_tumor_grades_analyzed + 1))) /
          count_tumor_grades_analyzed
      )
    ) +
    scale_y_continuous(
      name = "Proportion of tumor area",
      sec.axis = sec_axis(
        trans = ~ . * count_tumor_grades_analyzed,
        name = "Tumor Grade"
      )
    ) +
    scale_fill_manual(
      values = tumor_grade_colors,
      labels = rev(tumor_grade_labels),
      limits = tumor_grade_x_limits
    ) +
    # add descriptive title and subtitle
    ggtitle(
      "Proportion of tumor grade",
      paste("in individual tumors in", fg)
    ) +
    # remove x axis ticks and label
    theme(
      axis.title.x = element_blank(),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      legend.position = "bottom",
      plot.caption = element_text(
        hjust = 1,
        face = "italic"
      )
    ) +
    labs(
      caption = paste0(
        "Each bar represents an individual tumor.\n",
        downsample_method_description
      ),
      fill = "Area Grade"
    )
  print(plot_temp)
}
write.csv(graph_data, file.path(path_to_graph_data, "graph_041_data.csv"), row.names = FALSE)


figure_caption <- paste0(
  "Graph 041: Bar graph(s) of proportion of grades in individual tumors from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". Each bar represents a single tumor.",
  " Black dots indicate the overall tumor grade assigned based on the highest tumor grade present in the tumor that comprises ≥ 10% of the tumor area. ",
  downsample_method_description)
```

<a id="graph_042"></a>

```{r graph_042, fig.cap= figure_caption}
# plot number of grades present by tumor grade in each group
graph_data <- Tumor_Areas %>%
  select(
    individual_id,
    subindividual_id,
    full_group,
    all_of(full_grouping_vars),
    all_of(sample_info_vars),
    tumor_uid,
    tumor_grade,
    grades_present_in_tumor
  )

#downsample data randomly and adjust alpha values for plotting
downssampled_graph_data <- graph_data %>% 
  group_by(full_group) %>%
  slice_sample(n = 5000) 


plot1 <- downssampled_graph_data %>%
  ggplot(aes(
    x = reorder(tumor_grade, desc(tumor_grade)),
    y = grades_present_in_tumor,
    color = full_group,
    alpha = 0.3
  )) +
  geom_point(
    position = position_jitterdodge(
      jitter.width = 0.25,
      jitter.height = 0.4,
      dodge.width = 0.5
    ),
    size = 0.5
  ) +
  # add descriptive title and subtitle
  scale_color_manual(
    values = group_colors,
    labels = full_group_labels
  ) +
  scale_alpha_continuous(range = c(0.001,0.3),guide=FALSE) +
  scale_x_discrete(drop = FALSE,  limits = tumor_grade_x_limits)+
  scale_y_discrete(drop = FALSE,  limits = tumor_grade_x_limits)+
  ggtitle(
    "Grades present in individual tumors",
    paste("by", paste_to_text_list(c("tumor grade", full_grouping_vars_labels)))
  ) +
  guides(colour = guide_legend(override.aes = list(
    size = 3,
    alpha = 1
  ))) +
  labs(
    x = "Tumor Grade",
    y = "Number of Grades Present in Tumor",
    color = paste0(full_grouping_vars_labels, collapse = "\n"),
    caption = paste0(
      "Each dot represents an individual tumor.\n",
      "Groups with > 5000 tumors are randomly sampled."
    )
  )

write.csv(graph_data, file.path(path_to_graph_data, "graph_042_data.csv"), row.names = FALSE)

print(plot1)

figure_caption <- paste0(
  "Graph 042: Dot plot of number of grades present in individual tumors of each grade from each ",
  paste_to_text_list(full_grouping_vars_labels),
  ". Each point represents an individual tumor. ",
  "Groups with > 5000 tumors are randomly sampled."
  )
```

```{r end_of_he_analysis}
# DONE WITH H&E ANALYSIS
```

```{r add_ihc_headers, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
# make headings
if (do_ihc_analysis) {
  cat("## IHC analysis {.tabset .tabset-fade .tabset-pills} \n")
  cat("### Slide level analysis {.tabset .tabset-fade .tabset-pills} \n")
  cat("#### Whole slide analysis {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r initialize_ihc_containers, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
# initialize variables for storing plots for each IHC stain in the block of plots
ihc_plot_number <- 0
ihc_plots <- list()
plot_captions <- list()
```

```{r ihc_graph_001, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Plot of total IHC stained cells throughout each slide. This count includes both tumor and non-tumor areas."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = !!(as.name(stain_total_positive_in_slide_count[stain_number])),
        text = paste(
          "</br> Slide ID: ", slide_id,
          "</br> Animal ID: ", animal_id,
          "</br> Cell Count: ", !!(as.name(stain_total_positive_in_slide_count[stain_number]))
        )
      )) +
      # plot as points
      geom_point() +
      # label points
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cells in whole slide"),
        paste("per slide by", group_var_label)
      ) +
      # make y-axis label more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "positive cells")
      )
    plot_temp <- ggplotly_subtitle(plot_temp, hoverinfo = "text")
    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_002, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Plot of total IHC stained cells throught each slide by location in tumor or normal areas."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    data_temp <- Slide_Areas %>%
      select(c(slide_id, group, animal_id, !!(as.name(stain_total_positive_in_tumors_count[stain_number])), !!(as.name(stain_total_positive_in_slide_count[stain_number])))) %>%
      filter(!is.na(group)) %>%
      mutate(
        stain_total_positive_in_normal_count =
          !!(as.name(stain_total_positive_in_slide_count[stain_number])) - !!(as.name(stain_total_positive_in_tumors_count[stain_number]))
      ) %>%
      rename(Normal = 6, Tumor = 4) %>%
      pivot_longer(
        cols = c(Tumor, Normal),
        names_to = "Var",
        values_to = "Val"
      )

    plot_temp <- plot_ly(data_temp,
      x = ~group,
      y = ~Val,
      color = ~Var,
      colors = c("black", "red"),
      text = ~ paste(
        "</br> Slide ID: ", slide_id,
        "</br> Animal ID: ", animal_id,
        "</br> Cell Count: ", Val
      ),
      hoverinfo = "text",
      type = "box",
      boxpoints = "all",
      jitter = 0.3,
      pointpos = 0
    ) %>%
      layout(
        boxmode = "group",
        title = list(
          text = paste(
            ihc_stain_labels[stain_number],
            "positive cell counts in normal and tumor areas"
          ),
          x = 0.01,
          yanchor = "top",
          xanchor = "left"
        ),
        legend = list(title = list("Region")),
        xaxis = list(title = group_var_label),
        yaxis = list(title = paste(
          "Number of", ihc_stain_labels[stain_number],
          "positive cells"
        )),
        autosize = F,
        margin = list(t = 45)
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_stained_cell_counts, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  cat("##### Stained cell counts {.tabset .tabset-fade .tabset-pills} \n")
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }
  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r ihc_graph_003, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <-
    ("Stacked bar graph showing the proportion of the positively stained cells within the slide.
This does not account for differences in cell counts, tissue size, tumor counts, or tumor burden.")

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>% mutate(
      stain_positive_normal_percent = ((!!(as.name(stain_total_positive_in_slide_count[stain_number])) -
        !!(as.name(stain_total_positive_in_tumors_count[stain_number]))) /
        !!(as.name(stain_total_positive_in_slide_count[stain_number]))),
      stain_positive_tumor_percent = (!!(as.name(stain_total_positive_in_tumors_count[stain_number])) /
        !!(as.name(stain_total_positive_in_slide_count[stain_number])))
    ) %>%
      # pivot stained cell counts in area grades to put into a single plot
      pivot_longer(
        c(
          stain_positive_normal_percent,
          stain_positive_tumor_percent
        ),
        values_to = "positive_percent_in_areas",
        names_to = "area_type"
      ) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_percent_in_areas,
        fill = area_type,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = c("black", "red"), labels = c("Normal", "Tumor"),
        drop = FALSE
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Distribution of", ihc_stain_labels[stain_number], "positive cells"),
        "in normal and tumor area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste("Percent of", ihc_stain_labels[stain_number], "positive cells")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_004, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- paste("Boxplot showing the proportion of the positively stained cells within the slide for each", group_var_label, ".
This does not account for differences in cell counts, tissue size, tumor counts, or tumor burden.")

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>% mutate(
      stain_positive_normal_percent = ((!!(as.name(stain_total_positive_in_slide_count[stain_number])) -
        !!(as.name(stain_total_positive_in_tumors_count[stain_number]))) /
        !!(as.name(stain_total_positive_in_slide_count[stain_number]))),
      stain_positive_tumor_percent = (!!(as.name(stain_total_positive_in_tumors_count[stain_number])) /
        !!(as.name(stain_total_positive_in_slide_count[stain_number])))
    ) %>%
      # pivot stained cell counts in area grades to put into a single plot
      pivot_longer(
        c(
          stain_positive_normal_percent,
          stain_positive_tumor_percent
        ),
        values_to = "positive_percent_in_areas",
        names_to = "area_type"
      ) %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = positive_percent_in_areas,
        fill = area_type,
        color = group
      )) +
      # plot stacked bar graph
      geom_boxplot(alpha = 0.5, outlier.shape = NA) +
      geom_point(position = position_jitterdodge()) +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = c("black", "red"), labels = c("Normal", "Tumor"),
        drop = FALSE
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = group_labels) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Distribution of", ihc_stain_labels[stain_number], "positive cells"),
        "in normal and tumor area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = group_var_label,
        y = paste("Percent of", ihc_stain_labels[stain_number], "positive cells"),
        color = group_var_label,
        fill = "Area Type"
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_005, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <-
    ("Stacked bar graph showing the proportion of the cells within the slide that are positively stained in normal and tumor areas.
This does not account for differences in cell counts, tissue size, tumor counts, or tumor burden.
This is calculated using the total number of positively stained cells in each region divided by the total number of cells detected in the slide.")

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>% mutate(
      stain_positive_normal_percent = ((!!(as.name(stain_total_positive_in_slide_count[stain_number])) -
        !!(as.name(stain_total_positive_in_tumors_count[stain_number]))) /
        !!(as.name(stain_total_nuclei_in_slide_count[stain_number]))),
      stain_positive_tumor_percent = (!!(as.name(stain_total_positive_in_tumors_count[stain_number])) /
        !!(as.name(stain_total_nuclei_in_slide_count[stain_number])))
    ) %>%
      # pivot stained cell counts in area grades to put into a single plot
      pivot_longer(
        c(
          stain_positive_normal_percent,
          stain_positive_tumor_percent
        ),
        values_to = "positive_percent_in_areas",
        names_to = "area_type"
      ) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_percent_in_areas,
        fill = area_type,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = c("black", "red"), labels = c("Normal", "Tumor"),
        drop = FALSE
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Proportion of cells posively stained for", ihc_stain_labels[stain_number]),
        "in normal and tumor area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste("Percent of cells stained", ihc_stain_labels[stain_number], "positive")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_006, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- paste("Boxplot showing the proportion of the cells that positvely stained within the slide for each", group_var_label, ".
This does not account for differences in cell counts, tissue size, tumor counts, or tumor burden.
This is calculated using the total number of positively stained cells in each region divided by the total number of cells detected in the slide.")

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>% mutate(
      stain_positive_normal_percent = ((!!(as.name(stain_total_positive_in_slide_count[stain_number])) -
        !!(as.name(stain_total_positive_in_tumors_count[stain_number]))) /
        !!(as.name(stain_total_nuclei_in_slide_count[stain_number]))),
      stain_positive_tumor_percent = (!!(as.name(stain_total_positive_in_tumors_count[stain_number])) /
        !!(as.name(stain_total_nuclei_in_slide_count[stain_number])))
    ) %>%
      # pivot stained cell counts in area grades to put into a single plot
      pivot_longer(
        c(
          stain_positive_normal_percent,
          stain_positive_tumor_percent
        ),
        values_to = "positive_percent_in_areas",
        names_to = "area_type"
      ) %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = positive_percent_in_areas,
        fill = area_type,
        color = group
      )) +
      # plot stacked bar graph
      geom_boxplot(alpha = 0.5, outlier.shape = NA) +
      geom_point(position = position_jitterdodge()) +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = c("black", "red"), labels = c("Normal", "Tumor"),
        drop = FALSE
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = group_labels) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Proportion of cells posively stained for", ihc_stain_labels[stain_number]),
        paste("in normal and tumor area per", group_var_label)
      ) +
      # make y-axis label more descriptive
      labs(
        x = group_var_label,
        y = "Percent of cells stained", ihc_stain_labels[stain_number], "positive",
        color = group_var_label,
        fill = "Area Type"
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_stained_cell_proportions, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # add heading
  cat("##### Stained cell proportion {.tabset .tabset-fade .tabset-pills} \n")
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }

  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r ihc_graph_007, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Density of positively stained cells (per sq. mm) in each slide"

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = !!(as.name(stain_positive_density_in_slide[[stain_number]])),
        color = group
      )) +
      # plot stacked bar graph
      geom_point(stat = "identity") +
      # set point color to group colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE, guide = "none"
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to group labels
      scale_x_discrete(labels = group_labels) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell density"),
        "in each grade area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_008, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Density of positively stained cells (per sq. mm) in each slide by area type (Normal or Tumor)"

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      pivot_longer(
        cols = c(
          stain_positive_density_in_normal[[stain_number]],
          stain_positive_density_in_tumor[[stain_number]]
        ),
        values_to = "area_density",
        names_to = "area_type"
      ) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = area_density,
        color = group,
        fill = area_type
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # set point color to group colors
      scale_color_manual(
        values = group_colors,
        labels = group_labels,
        drop = FALSE
      ) +
      scale_fill_manual(
        values = c("black", "red"),
        labels = c("Normal", "Tumor"),
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to group labels
      scale_x_discrete(labels = slide_number_to_id) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell density"),
        "in each grade area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm"),
        fill = "Area Type",
        color = group_var_label
      ) +
      facet_grid(rows = vars(area_type))

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_009, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Average density of positively stained cells by area grade in each group"

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # group by group_var for comparisons
      group_by(group) %>%
      # calculate stained cell density in each grade area and convert to sq. mm
      summarise(
        grade1_positive_density_mean =
          mean(!!(as.name(stain_positive_grade1_count[stain_number])) / (grade1_area_in_slide / (1000^2)),
            na.rm = TRUE
          ),
        grade2_positive_density_mean =
          mean(!!(as.name(stain_positive_grade2_count[stain_number])) / (grade2_area_in_slide / (1000^2)),
            na.rm = TRUE
          ),
        grade3_positive_density_mean =
          mean(!!(as.name(stain_positive_grade3_count[stain_number])) / (grade3_area_in_slide / (1000^2)),
            na.rm = TRUE
          ),
        grade4_positive_density_mean =
          mean(!!(as.name(stain_positive_grade4_count[stain_number])) / (grade4_area_in_slide / (1000^2)),
            na.rm = TRUE
          )
      ) %>%
      # pivot grade are percent positive to put into a single graph
      pivot_longer(
        c(
          grade1_positive_density_mean,
          grade2_positive_density_mean,
          grade3_positive_density_mean,
          grade4_positive_density_mean
        ),
        values_to = "grade_positive_density_mean",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          "grade4_positive_density_mean",
          "grade3_positive_density_mean",
          "grade2_positive_density_mean",
          "grade1_positive_density_mean"
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = grade_positive_density_mean,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors,
        labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors,
        drop = FALSE # don't remove legend if no visible values)
      ) +
      # add formatted labels for each group to x-axis
      scale_x_discrete(labels = group_labels) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Mean", ihc_stain_labels[stain_number], "positive cell density in tumors"),
        paste("per slide by", group_var_label)
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # make axis labels more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_010, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Density of positive nuclei within each grade per slide."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # pivot positive cell counts in area grades to show in single plot
      pivot_longer(
        c(
          stain_positive_grade1_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade4_density[stain_number]
        ),
        values_to = "positive_density_in_areas",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          stain_positive_grade4_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade1_density[stain_number]
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_density_in_areas,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors, labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # facet plot on area grade for easier comparisons
      facet_wrap(vars(area_grade)) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell density"),
        "within each grade area per slide"
      ) +
      # make axis labels more descriptive
      labs(
        x = "Slide ID",
        y = paste(ihc_stain_labels[stain_number], "+ cells / sq. mm")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_011, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Plot description goes here..."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    Slide_Areas_longer <- Slide_Areas %>%
      pivot_longer(
        c(
          stain_positive_grade1_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade4_density[stain_number]
        ),
        values_to = "area_density_positive",
        names_to = "area_grade"
      )

    # stat.test <- Slide_Areas_longer %>% group_by(area_grade) %>%
    # t_test(area_percent_positive ~ group, p.adjust.method = "none") %>%
    # adjust_pvalue(method = "none") %>%
    # add_significance("p")

    # stat.test

    # stat.test <- stat.test %>% add_xy_position(x = "area_grade", group = "group", dodge = 1, fun = "max", scales = "free")


    # plot proportion of positive nuclei within each grade per group
    plot_temp <- Slide_Areas_longer %>%
      ggplot(aes(
        x = area_grade,
        y = area_density_positive,
        fill = area_fill,
        color = group
      )) +
      geom_boxplot(position = position_dodge(width = .9), width = 0.75, outlier.size = 0.5) +
      # stat_pvalue_manual(stat.test,
      #                  hide.ns = TRUE,
      #                  tip.length = 0,
      #                  step.increase = 0.05,
      #                  label = "p.signif") +
      scale_y_continuous(expand = expansion(mult = c(0, 0.25))) +
      scale_fill_manual(values = rev(tumor_grade_colors), labels = rev(tumor_grade_labels)) + # fill bars using colors based on area grade
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) + # outline bars using colors based on group
      scale_x_discrete(labels = rev(tumor_grade_labels)) + # change x axis tick labels to slide id
      ggtitle(paste(ihc_stain_labels[stain_number], "positive cell proportion", "\nwithin each grade area per", group_var_label)) + # add descriptive title and subtitle
      theme(legend.position = "bottom", legend.box = "vertical") + # move legends to bottom
      labs(x = "Tumor area grade", y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm")) # make y-axis label more descriptive

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_stained_cell_densities, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # add heading
  cat("##### Stained cell density {.tabset .tabset-fade .tabset-pills} \n")
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }

  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()

  # add headings
}
```

```{r tumor_only_ihc_analysis}
if (do_ihc_analysis) {
  cat("#### Tumor-only IHC analysis {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r tumor_stained_cell_counts}
if (do_ihc_analysis) {
  cat("##### Stained cell counts {.tabset .tabset-fade .tabset-pills} \n\n")
}
```

```{r ihc_graph_012, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Plot count of IHC stained cells in each slide
  plot_caption <- "Plot of total IHC stained cells in the tumor areas of each slide annotated by GLASS-AI."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = !!(as.name(stain_total_positive_in_tumors_count[stain_number]))
      )) +
      # plot as points
      geom_point() +
      # label points
      geom_text(aes(label = slide_id), hjust = 1.2, vjust = 0) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cells in tumors"),
        paste("per slide by", group_var_label)
      ) +
      # make y-axis label more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "positive cells")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Description of this plot goes here..."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = !!(as.name(stain_total_positive_in_tumors_count[stain_number])),
        color = group
      )) +
      # make grouped box plots
      geom_boxplot(position = position_dodge(1), outlier.shape = NA) +
      # overlay data points on box plots
      geom_point(position = position_jitterdodge(0.4), size = 0.4) +
      # add pairwise statistical comparisons to reference group
      stat_compare_means(
        comparisons = full_group_comparisons, method = "t.test",
        show.legend = FALSE, label = "p.format", tip.length = 0
      ) +
      # outline boxes with group color
      scale_color_manual(
        values = group_colors,
        labels = group_labels
      ) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Mean", ihc_stain_labels[stain_number], "positive count in tumors"),
        paste("by", group_var_label)
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # make axis labels more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "positive count in tumors")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_013, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Description of this plot goes here..."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # pivot counts per grade area to show on same graph
      pivot_longer(
        c(
          stain_positive_grade1_count[stain_number],
          stain_positive_grade2_count[stain_number],
          stain_positive_grade3_count[stain_number],
          stain_positive_grade4_count[stain_number]
        ),
        values_to = "positive_count_in_areas",
        names_to = "area_grade"
      ) %>%
      # refactor so grade 4 is on top in the graph
      mutate(area_grade = factor(area_grade,
        levels = c(
          stain_positive_grade4_count[stain_number],
          stain_positive_grade3_count[stain_number],
          stain_positive_grade2_count[stain_number],
          stain_positive_grade1_count[stain_number]
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_count_in_areas,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with grade color
      scale_fill_manual(values = tumor_grade_colors) +
      # outline bars with group color
      scale_color_manual(values = group_colors, drop = FALSE) +
      # rotate x-axis text 45
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # add descriptive title and subtitle
      ggtitle(
        paste(
          ihc_stain_labels[stain_number],
          "positive cell count"
        ),
        "in each grade area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste(
          ihc_stain_labels[stain_number],
          "positive cell count"
        )
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_014, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Description of this plot goes here..."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # group data by group_var for comparison
      group_by(group) %>%
      # calculate the mean positive cell count in each area grade
      summarise(
        grade1_positive_mean =
          mean(!!(as.name(stain_positive_grade1_count[stain_number])), na.rm = TRUE),
        grade2_positive_mean =
          mean(!!(as.name(stain_positive_grade2_count[stain_number])), na.rm = TRUE),
        grade3_positive_mean =
          mean(!!(as.name(stain_positive_grade3_count[stain_number])), na.rm = TRUE),
        grade4_positive_mean =
          mean(!!(as.name(stain_positive_grade4_count[stain_number])), na.rm = TRUE)
      ) %>%
      # pivot gradeX_area_mean columns to put into a single plot
      pivot_longer(
        c(
          grade1_positive_mean, grade2_positive_mean,
          grade3_positive_mean, grade4_positive_mean
        ),
        values_to = "grade_positive_mean",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          "grade4_positive_mean",
          "grade3_positive_mean",
          "grade2_positive_mean",
          "grade1_positive_mean"
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = grade_positive_mean,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with grade color
      scale_fill_manual(
        values = tumor_grade_colors,
        labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # outline bars with group color
      scale_color_manual(
        values = group_colors,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Mean", ihc_stain_labels[stain_number], "positive count in tumors"),
        paste("per slide by", group_var_label)
      )
    # rotate x-axis text 45˚
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # make axis labels more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "positive cell count")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_tumor_stained_cell_counts, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }
  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r tumor_stained_cell_proportions}
if (do_ihc_analysis) {
  # add heading
  cat("##### Stained cell proportion {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r ihc_graph_015, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <-
    ("Stacked bar graph showing the proportion of the positively stained cells within the tumor regions by the grade of the area they are located in.
This does not consider any cells outside of the tumor area, stained or unstained.
This does not account for differences in cell counts, tumor counts, or tumor burden.")

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # pivot stained cell counts in area grades to put into a single plot
      pivot_longer(
        c(
          stain_positive_grade1_percent[stain_number],
          stain_positive_grade2_percent[stain_number],
          stain_positive_grade3_percent[stain_number],
          stain_positive_grade4_percent[stain_number]
        ),
        values_to = "positive_percent_in_areas",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          stain_positive_grade4_percent[stain_number],
          stain_positive_grade3_percent[stain_number],
          stain_positive_grade2_percent[stain_number],
          stain_positive_grade1_percent[stain_number]
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_percent_in_areas,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors, labels = tumor_grade_labels,
        drop = FALSE
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell percentage"),
        "in each grade area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste("Percent of", ihc_stain_labels[stain_number], "positive cells")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_016, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Average proportion of positively stained cells by area grade in each slide"

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # group by group_var for comparisons
      group_by(group) %>%
      summarise(
        grade1_positive_percent_mean =
          mean(!!(as.name(stain_positive_grade1_percent[stain_number])),
            na.rm = TRUE
          ),
        grade2_positive_percent_mean =
          mean(!!(as.name(stain_positive_grade2_percent[stain_number])),
            na.rm = TRUE
          ),
        grade3_positive_percent_mean =
          mean(!!(as.name(stain_positive_grade3_percent[stain_number])),
            na.rm = TRUE
          ),
        grade4_positive_percent_mean =
          mean(!!(as.name(stain_positive_grade4_percent[stain_number])),
            na.rm = TRUE
          )
      ) %>%
      # pivot grade are percent positive to put into a single graph
      pivot_longer(
        c(
          grade1_positive_percent_mean,
          grade2_positive_percent_mean,
          grade3_positive_percent_mean,
          grade4_positive_percent_mean
        ),
        values_to = "grade_positive_percent_mean",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          "grade4_positive_percent_mean",
          "grade3_positive_percent_mean",
          "grade2_positive_percent_mean",
          "grade1_positive_percent_mean"
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = grade_positive_percent_mean,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors,
        labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors,
        drop = FALSE # don't remove legend if no visible values)
      ) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Mean", ihc_stain_labels[stain_number], "positive percent in tumors"),
        paste("per slide by", group_var_label)
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # make axis labels more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "positive cell percent")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_017, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "proportion of positive nuclei within each grade per slide."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # pivot positive cell counts in area grades to show in single plot
      pivot_longer(
        c(
          grade1_percent_positive_nuclei[stain_number],
          grade2_percent_positive_nuclei[stain_number],
          grade3_percent_positive_nuclei[stain_number],
          grade4_percent_positive_nuclei[stain_number]
        ),
        values_to = "positive_percent_in_areas",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          grade4_percent_positive_nuclei[stain_number],
          grade3_percent_positive_nuclei[stain_number],
          grade2_percent_positive_nuclei[stain_number],
          grade1_percent_positive_nuclei[stain_number]
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_percent_in_areas,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors, labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # facet plot on area grade for easier comparisons
      facet_wrap(vars(area_grade)) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell proportion"),
        "within each grade area per slide"
      ) +
      # make axis labels more descriptive
      labs(
        x = "Slide ID",
        y = paste(ihc_stain_labels[stain_number], "positive cell proportion")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_018, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Plot description goes here..."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    Slide_Areas_longer <- Slide_Areas %>%
      pivot_longer(
        c(
          grade1_percent_positive_nuclei[stain_number],
          grade2_percent_positive_nuclei[stain_number],
          grade3_percent_positive_nuclei[stain_number],
          grade4_percent_positive_nuclei[stain_number]
        ),
        values_to = "area_percent_positive",
        names_to = "area_grade"
      )

    # stat.test <- Slide_Areas_longer %>% group_by(area_grade) %>%
    # t_test(area_percent_positive ~ group, p.adjust.method = "none") %>%
    # adjust_pvalue(method = "none") %>%
    # add_significance("p")

    # stat.test

    # stat.test <- stat.test %>% add_xy_position(x = "area_grade", group = "group", dodge = 1, fun = "max", scales = "free")


    # plot proportion of positive nuclei within each grade per group
    plot_temp <- Slide_Areas_longer %>%
      ggplot(aes(
        x = area_grade,
        y = area_percent_positive,
        fill = area_fill,
        color = group
      )) +
      geom_boxplot(position = position_dodge(width = .9), width = 0.75, outlier.size = 0.5) +
      # stat_pvalue_manual(stat.test,
      #                  hide.ns = TRUE,
      #                  tip.length = 0,
      #                  step.increase = 0.05,
      #                  label = "p.signif") +
      scale_y_continuous(expand = expansion(mult = c(0, 0.25))) +
      scale_fill_manual(values = rev(tumor_grade_colors), labels = rev(tumor_grade_labels)) + # fill bars using colors based on area grade
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) + # outline bars using colors based on group
      scale_x_discrete(labels = rev(tumor_grade_labels)) + # change x axis tick labels to slide id
      ggtitle(paste(ihc_stain_labels[stain_number], "positive cell proportion", "\nwithin each grade area per", group_var_label)) + # add descriptive title and subtitle
      theme(legend.position = "bottom", legend.box = "vertical") + # move legends to bottom
      labs(x = "Tumor area grade", y = paste(ihc_stain_labels[stain_number], "positive cell proportion")) # make y-axis label more descriptive

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_tumor_stained_cell_proportions, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }
  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r tumor_stained_cell_densities, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # add heading
  cat("##### Stained cell density {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r ihc_graph_019, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Average density of positively stained cells by area grade in each slide"

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # pivot stained cell counts in area grades to put into a single plot
      pivot_longer(
        c(
          stain_positive_grade1_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade4_density[stain_number]
        ),
        values_to = "positive_density_in_areas",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          stain_positive_grade4_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade1_density[stain_number]
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_density_in_areas,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors, labels = tumor_grade_labels,
        drop = FALSE
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE
      ) +
      # rotate x-axis text 45
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        plot.caption.position = "plot",
        legend.position = "bottom",
        legend.box = "vertical",
        plot.caption = element_text(hjust = 0),
      ) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell density"),
        "in each grade area per slide"
      ) +
      # make y-axis label more descriptive
      labs(
        x = "Slide ID",
        y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_020, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Average density of positively stained cells by area grade in each group"

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # group by group_var for comparisons
      group_by(group) %>%
      # calculate stained cell density in each grade area and convert to sq. mm
      summarise(
        grade1_positive_density_mean =
          mean(!!(as.name(stain_positive_grade1_count[stain_number])) / (grade1_area_in_slide / (1000^2)),
            na.rm = TRUE
          ),
        grade2_positive_density_mean =
          mean(!!(as.name(stain_positive_grade2_count[stain_number])) / (grade2_area_in_slide / (1000^2)),
            na.rm = TRUE
          ),
        grade3_positive_density_mean =
          mean(!!(as.name(stain_positive_grade3_count[stain_number])) / (grade3_area_in_slide / (1000^2)),
            na.rm = TRUE
          ),
        grade4_positive_density_mean =
          mean(!!(as.name(stain_positive_grade4_count[stain_number])) / (grade4_area_in_slide / (1000^2)),
            na.rm = TRUE
          )
      ) %>%
      # pivot grade are percent positive to put into a single graph
      pivot_longer(
        c(
          grade1_positive_density_mean,
          grade2_positive_density_mean,
          grade3_positive_density_mean,
          grade4_positive_density_mean
        ),
        values_to = "grade_positive_density_mean",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          "grade4_positive_density_mean",
          "grade3_positive_density_mean",
          "grade2_positive_density_mean",
          "grade1_positive_density_mean"
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = group,
        y = grade_positive_density_mean,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors,
        labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # outline bars with group_var colors
      scale_color_manual(
        values = group_colors,
        drop = FALSE # don't remove legend if no visible values)
      ) +
      # add formated labels for each group to x-axis
      scale_x_discrete(labels = group_labels) +
      # add descriptive title and subtitle
      ggtitle(
        paste("Mean", ihc_stain_labels[stain_number], "positive cell density in tumors"),
        paste("per slide by", group_var_label)
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # make axis labels more descriptive
      labs(
        x = group_var_label,
        y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_021, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Density of positive nuclei within each grade per slide."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # make plot
    plot_temp <- Slide_Areas %>%
      # pivot positive cell counts in area grades to show in single plot
      pivot_longer(
        c(
          stain_positive_grade1_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade4_density[stain_number]
        ),
        values_to = "positive_density_in_areas",
        names_to = "area_grade"
      ) %>%
      # rearrange graph so grade 4 is on top
      mutate(area_grade = factor(area_grade,
        levels = c(
          stain_positive_grade4_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade1_density[stain_number]
        )
      )) %>%
      # define plot variables
      ggplot(aes(
        x = slide_number,
        y = positive_density_in_areas,
        fill = area_grade,
        color = group
      )) +
      # plot stacked bar graph
      geom_bar(position = "stack", stat = "identity") +
      # fill bars with tumor grade colors
      scale_fill_manual(
        values = tumor_grade_colors, labels = tumor_grade_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      scale_color_manual(
        values = group_colors, labels = group_labels,
        drop = FALSE # don't remove legend if no visible values
      ) +
      # rotate x-axis text 45˚
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      # change x axis tick labels to slide id
      scale_x_discrete(labels = slide_number_to_id) +
      # facet plot on area grade for easier comparisons
      facet_wrap(vars(area_grade)) +
      # add descriptive title and subtitle
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cell density"),
        "within each grade area per slide"
      ) +
      # make axis labels more descriptive
      labs(
        x = "Slide ID",
        y = paste(ihc_stain_labels[stain_number], "+ cells / sq. mm")
      )

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_022, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # Describe what the plot shows
  plot_caption <- "Plot description goes here..."

  # set up storage variables
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  # iterate over each stain and generate plot
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    Slide_Areas_longer <- Slide_Areas %>%
      pivot_longer(
        c(
          stain_positive_grade1_density[stain_number],
          stain_positive_grade2_density[stain_number],
          stain_positive_grade3_density[stain_number],
          stain_positive_grade4_density[stain_number]
        ),
        values_to = "area_density_positive",
        names_to = "area_grade"
      )

    # stat.test <- Slide_Areas_longer %>% group_by(area_grade) %>%
    # t_test(area_percent_positive ~ group, p.adjust.method = "none") %>%
    # adjust_pvalue(method = "none") %>%
    # add_significance("p")

    # stat.test

    # stat.test <- stat.test %>% add_xy_position(x = "area_grade", group = "group", dodge = 1, fun = "max", scales = "free")


    # plot proportion of positive nuclei within each grade per group
    plot_temp <- Slide_Areas_longer %>%
      ggplot(aes(
        x = area_grade,
        y = area_density_positive,
        fill = area_grade,
        color = group
      )) +
      geom_boxplot(position = position_dodge(width = .9), width = 0.75, outlier.size = 0.5) +
      # stat_pvalue_manual(stat.test,
      #                  hide.ns = TRUE,
      #                  tip.length = 0,
      #                  step.increase = 0.05,
      #                  label = "p.signif") +
      scale_y_continuous(expand = expansion(mult = c(0, 0.25))) +
      scale_fill_manual(values = rev(tumor_grade_colors), labels = rev(tumor_grade_labels)) + # fill bars using colors based on area grade
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) + # outline bars using colors based on group
      scale_x_discrete(labels = rev(tumor_grade_labels)) + # change x axis tick labels to slide id
      ggtitle(paste(ihc_stain_labels[stain_number], "positive cell proportion", "\nwithin each grade area per", group_var_label)) + # add descriptive title and subtitle
      theme(legend.position = "bottom", legend.box = "vertical") + # move legends to bottom
      labs(x = "Tumor area grade", y = paste(ihc_stain_labels[stain_number], "+ cells/ sq. mm")) # make y-axis label more descriptive

    # add generated plot for each stain to list of plots
    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_tumor_stained_cell_densities, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }
  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r peritumor_ihc_analysis}
if (do_ihc_analysis) {
  # add headings
  cat("#### Peri-tumor IHC analysis {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r peritumor_stained_cell_counts}
if (do_ihc_analysis) {
  # add headings
  cat("##### Stained cell counts {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r ihc_graph_023, include=FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # plot count of positive cells in tumor regions for each slide
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # dot plot number of positive cells in peritumor regions  in each slide by group_var
    plot_temp <- Slide_Areas %>%
      pivot_longer(
        c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
        values_to = "peritumor_positive_count",
        names_to = "distance"
      ) %>%
      # rearrange graph so largest distance is on top
      mutate(distance = factor(
        distance,
        levels = c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
      )) %>%
      ggplot(aes(
        x = distance,
        y = peritumor_positive_count,
        color = group
      )) +
      geom_point(position = position_dodge(.5)) +
      scale_x_discrete(labels = c("250 µm", "150 µm", "100 µm", "50 µm", "tumor")) +
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cells in peritumor region"),
        paste("per slide by", group_var_label)
      ) + # add descriptive title and subtitle
      labs(x = "Distance from tumor", y = paste(ihc_stain_labels[stain_number], "positive cells")) # make y-axis label more descriptive

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- "dot plot number of positive cells in peritumor regions  in each slide by group_var"

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_024, include = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # plot boxplot of count of positive cells in tumor regions for each slide
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # box plot number of positive cells in peritumor regions in each slide by group_var

    plot_temp <- Slide_Areas %>%
      pivot_longer(
        c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
        values_to = "peritumor_positive_count",
        names_to = "distance"
      ) %>%
      # rearrange graph so largest distance is on top
      mutate(distance = factor(
        distance,
        levels = c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
        labels = c("250µm", "150µm", "100µm", "50µm", "Tumor")
      )) %>%
      ggplot(aes(
        x = group,
        y = peritumor_positive_count,
        color = group
      )) +
      facet_wrap(~distance, scales = "fixed", nrow = 1) +
      geom_boxplot(width = 0.2, position = position_dodge(.5)) +
      stat_compare_means(
        method = "t.test",
        label.x.npc = 0.5,
        show.legend = FALSE,
        tip.length = 0,
        label = "p.signif",
        comparisons = full_group_comparisons
      ) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.25))) +
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) +
      ggtitle(
        paste(ihc_stain_labels[stain_number], "positive cells in peritumor region"),
        paste("per slide by", group_var_label)
      ) + # add descriptive title and subtitle
      theme(
        plot.caption.position = "plot", legend.position = "bottom",
        legend.box = "horizontal", plot.caption = element_text(hjust = 0),
        axis.text.x = element_blank()
      ) +
      labs(x = group_var_label, y = paste(ihc_stain_labels[stain_number], "positive cells")) # make y-axis label more descriptive

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- paste("box plot number of positive cells in peritumor regions in each slide by", group_var_label)

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_025, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # plot counts of positive cells within peritumor and tumor region for each slide
    plot_temp <- Slide_Areas %>%
      pivot_longer(
        c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
        values_to = "peritumor_positive_count",
        names_to = "distance"
      ) %>%
      # rearrange graph so largest distance is on top
      mutate(distance = factor(
        distance,
        levels = c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
      )) %>%
      ggplot(aes(
        x = slide_number,
        y = peritumor_positive_count,
        fill = distance,
        color = group
      )) +
      geom_bar(stat = "identity", position = "stack") +
      scale_fill_viridis_d(labels = c("250 µm", "150 µm", "100 µm", "50 µm", "tumor")) + # fill bars using colors based on area grade
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) + # outline bars using colors based on group
      scale_x_discrete(labels = slide_number_to_id) + # change x axis tick labels to slide id
      ggtitle(paste(ihc_stain_labels[stain_number], "positive cell count", "\nwithin the peritumor region of each slide")) + # add descriptive title and subtitle
      theme(
        legend.position = "bottom", legend.box = "vertical",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
      ) + # move legends to bottom
      labs(x = group_var_label, y = paste(ihc_stain_labels[stain_number], "positive cell count")) # make y-axis label more descriptive

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- "plot counts of positive cells within peritumor and tumor region for each slide"

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_026, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # plot counts of positive cells within peritumor and tumor region for each slide
    plot_temp <- Slide_Areas %>%
      group_by(group) %>%
      summarise( # calculate mean counts within each group
        stain_250micron_positive_count_mean = mean(!!(as.name(stain_250micron_positive_count[stain_number])), na.rm = TRUE),
        stain_150micron_positive_count_mean = mean(!!(as.name(stain_150micron_positive_count[stain_number])), na.rm = TRUE),
        stain_100micron_positive_count_mean = mean(!!(as.name(stain_100micron_positive_count[stain_number])), na.rm = TRUE),
        stain_50micron_positive_count_mean = mean(!!(as.name(stain_50micron_positive_count[stain_number])), na.rm = TRUE),
        stain_total_positive_in_tumors_count_mean = mean(!!(as.name(stain_total_positive_in_tumors_count[stain_number])), na.rm = TRUE)
      ) %>%
      pivot_longer(
        c(
          stain_250micron_positive_count_mean,
          stain_150micron_positive_count_mean,
          stain_100micron_positive_count_mean,
          stain_50micron_positive_count_mean,
          stain_total_positive_in_tumors_count_mean
        ),
        values_to = "peritumor_positive_count_mean",
        names_to = "distance"
      ) %>%
      # rearrange graph so largest distance is on top
      mutate(distance = factor(
        distance,
        levels = c(
          "stain_250micron_positive_count_mean",
          "stain_150micron_positive_count_mean",
          "stain_100micron_positive_count_mean",
          "stain_50micron_positive_count_mean",
          "stain_total_positive_in_tumors_count_mean"
        ),
      )) %>%
      ggplot(aes(
        x = group,
        y = peritumor_positive_count_mean,
        fill = distance,
        color = group
      )) +
      geom_bar(stat = "identity", position = "stack") +
      scale_fill_viridis_d(labels = c("250 µm", "150 µm", "100 µm", "50 µm", "tumor")) + # fill bars using colors based on area grade
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) + # outline bars using colors based on group
      scale_x_discrete(labels = group_labels) + # change x axis tick labels to slide id
      ggtitle(paste("Mean", ihc_stain_labels[stain_number], "positive cell count", "\nwithin the peritumor region of each slide")) + # add descriptive title and subtitle
      theme(legend.position = "bottom", legend.box = "vertical") + # move legends to bottom
      labs(x = group_var_label, y = paste("Mean", ihc_stain_labels[stain_number], "positive cell count")) # make y-axis label more descriptive

    ihc_plots_temp[[stain_number]] <- plot_temp
  }

  plot_caption <- paste("plot mean counts of positive cells within peritumor and tumor region for each", group_var_label)

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r ihc_graph_027, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()
  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1

    # plot counts of positive cells within peritumor and tumor region for each slide
    plot_temp <- Slide_Areas %>%
      pivot_longer(
        c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
        values_to = "peritumor_positive_count",
        names_to = "distance"
      ) %>%
      # rearrange graph so largest distance is on top
      mutate(distance = factor(
        distance,
        levels = c(
          stain_250micron_positive_count[stain_number],
          stain_150micron_positive_count[stain_number],
          stain_100micron_positive_count[stain_number],
          stain_50micron_positive_count[stain_number],
          stain_total_positive_in_tumors_count[stain_number]
        ),
      )) %>%
      ggplot(aes(
        x = slide_number,
        y = peritumor_positive_count,
        fill = distance,
        color = group
      )) +
      geom_bar(stat = "identity", position = "stack") +
      scale_fill_viridis_d(labels = c("250 µm", "150 µm", "100 µm", "50 µm", "tumor")) + # fill bars using colors based on area grade
      scale_color_manual(values = group_colors, labels = group_labels, drop = FALSE) + # outline bars using colors based on group
      scale_x_discrete(labels = slide_number_to_id) + # change x axis tick labels to slide id
      ggtitle(paste(ihc_stain_labels[stain_number], "positive cell count", "\nwithin the peritumor region of each slide")) + # add descriptive title and subtitle
      theme(
        legend.position = "bottom", legend.box = "vertical",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
      ) + # move legends to bottom
      labs(x = group_var_label, y = paste(ihc_stain_labels[stain_number], "positive cell count")) # make y-axis label more descriptive

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- "plot counts of positive cells within peritumor and tumor region for each slide"

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_peritumor_stained_cell_counts, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }

  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r multi_ihc_analysis}
if (do_ihc_analysis) {
  # add headings
  cat("#### Multiple IHC analysis {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r multi_stained_cell_counts}
if (do_ihc_analysis) {
  # add headings
  cat("##### Stained cell counts {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r ihc_graph_028, echo = FALSE, message = FALSE, warning = FALSE, results='asis'}
if (do_ihc_analysis) {
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1
    first_stain_label <- ihc_stain_labels[stain_number]
    second_stain_list <- ihc_stain_list[-stain_number]
    second_stain_label_list <- ihc_stain_labels[-stain_number]
    second_stain_number <- 0
    for (second_stain in second_stain_list) {
      second_stain_number <- second_stain_number + 1
      second_stain_label <- second_stain_label_list[second_stain_number]
      # make a new tibble containing only tumors from slides stained for both targets
      double_stained_Tumor_Areas <- Tumor_Areas %>%
        filter(!(is.na(!!as.name(paste(stain, "stain_image_id", sep = "_"))) |
          is.na(!!as.name(paste(second_stain, "stain_image_id", sep = "_")))))

      # plot stain1_percent by stain2_percent as scatter plot. Facet by group
      plot1 <- double_stained_Tumor_Areas %>%
        ggplot(aes(
          x = log10(double_stained_Tumor_Areas[[paste(stain, "total_positive_nuclei_in_tumor", sep = "_")]] + 1),
          y = log10(double_stained_Tumor_Areas[[paste(second_stain, "total_positive_nuclei_in_tumor", sep = "_")]] + 1),
          color = group,
          alpha = 0.5
        )) +
        geom_point(alpha = 0.2) +
        scale_x_continuous() +
        scale_y_continuous() +
        scale_color_manual(
          values = group_colors,
          labels = group_labels,
          guide = "none"
        ) +
        labs(
          x = paste("Log10 ", first_stain_label, "+ cell count"),
          y = paste("Log10 ", second_stain_label, "+ cell count")
        ) +
        theme(aspect.ratio = 1) + # make plots square
        facet_wrap(~group, nrow = 1)

      # plot stain1_percent by stain2_percent as 2D density plot. Facet by group.
      plot2 <- double_stained_Tumor_Areas %>%
        ggplot(aes(
          x = log10(double_stained_Tumor_Areas[[paste(stain, "total_positive_nuclei_in_tumor", sep = "_")]] + 1),
          y = log10(double_stained_Tumor_Areas[[paste(second_stain, "total_positive_nuclei_in_tumor", sep = "_")]] + 1),
          color = group
        )) +
        geom_density_2d(contour_var = "ndensity", binwidth = 0.01) +
        scale_x_continuous() +
        scale_y_continuous() +
        scale_color_manual(
          values = group_colors,
          labels = group_labels,
          guide = "none"
        ) +
        labs(
          x = paste("Log10 ", first_stain_label, "+ cell count"),
          y = paste("Log10 ", second_stain_label, "+ cell count")
        ) +
        theme(aspect.ratio = 1) + # make plots square
        facet_wrap(~group, nrow = 1)




      plot_temp <- plot_grid(plot1, plot2, nrow = 2)
      ihc_plots_temp[[length(ihc_stain_list) * (stain_number - 1) + second_stain_number]] <- plot_temp
    }

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- "Plots of count of cells within tumors that are positive for each IHC marker"

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_multi_stained_cell_counts, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }

  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r multi_ihc_stained_cell_proportions}
if (do_ihc_analysis) {
  # add heading
  cat("##### Stained cell proportions {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r ihc_graph_029, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1
    first_stain_label <- ihc_stain_labels[stain_number]
    second_stain_list <- ihc_stain_list[-stain_number]
    second_stain_label_list <- ihc_stain_labels[-stain_number]
    second_stain_number <- 0
    for (second_stain in second_stain_list) {
      second_stain_number <- second_stain_number + 1
      second_stain_label <- second_stain_label_list[second_stain_number]
      # make a new tibble containing only tumors from slides stained for both targets
      double_stained_Tumor_Areas <- Tumor_Areas %>%
        filter(!(is.na(!!as.name(paste(stain, "total_number_nuclei_in_tumor", sep = "_"))) |
          is.na(!!as.name(paste(second_stain, "total_number_nuclei_in_tumor", sep = "_")))))

      # calculate the percent of positively stained cells in each tumor for stain1
      stain1_percent <- double_stained_Tumor_Areas[[paste(stain, "total_positive_nuclei_in_tumor", sep = "_")]] /
        double_stained_Tumor_Areas[[paste(stain, "total_number_nuclei_in_tumor", sep = "_")]]

      # calculate the percent of positively stained cells in each tumor for stain2
      stain2_percent <- double_stained_Tumor_Areas[[paste(second_stain, "total_positive_nuclei_in_tumor", sep = "_")]] /
        double_stained_Tumor_Areas[[paste(second_stain, "total_number_nuclei_in_tumor", sep = "_")]]

      # plot stain1_percent by stain2_percent as scatter plot. Facet by group
      plot1 <- double_stained_Tumor_Areas %>%
        ggplot(aes(
          x = stain1_percent,
          y = stain2_percent,
          color = group,
          alpha = 0.5
        )) +
        geom_point(alpha = 0.2) +
        scale_x_continuous(limits = c(0, 1)) +
        scale_y_continuous(limits = c(0, 1)) +
        scale_color_manual(
          values = group_colors,
          labels = group_labels,
          guide = "none"
        ) +
        labs(
          x = paste("%", first_stain_label, "+"),
          y = paste("%", second_stain_label, "+")
        ) +
        facet_wrap(~group, nrow = 1)

      # plot stain1_percent by stain2_percent as 2D density plot. Facet by group.
      plot2 <- double_stained_Tumor_Areas %>%
        ggplot(aes(
          x = stain1_percent,
          y = stain2_percent,
          color = group
        )) +
        geom_density_2d(contour_var = "ndensity", binwidth = 0.01) +
        scale_x_continuous(limits = c(0, 1)) +
        scale_y_continuous(limits = c(0, 1)) +
        scale_color_manual(
          values = group_colors,
          labels = group_labels,
          guide = "none"
        ) +
        labs(
          x = paste("%", first_stain_label, "+"),
          y = paste("%", second_stain_label, "+")
        ) +
        facet_wrap(~group, nrow = 1)




      plot_temp <- plot_grid(plot1, plot2, nrow = 2)
      ihc_plots_temp[[length(ihc_stain_list) * (stain_number - 1) + second_stain_number]] <- plot_temp
    }

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- "Plots of proportion of cells within tumors that are positive for each IHC marker"

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_multi_ihc_stained_cell_proportions, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }

  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r multi_ihc_stained_cell_densities}
if (do_ihc_analysis) {
  # add heading
  cat("##### Stained cell densities {.tabset .tabset-fade .tabset-pills} \n")
}
```

```{r ihc_graph_030, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  ihc_plot_number <- ihc_plot_number + 1
  stain_number <- 0
  ihc_plots_temp <- list()

  for (stain in ihc_stain_list) {
    stain_number <- stain_number + 1
    first_stain_label <- ihc_stain_labels[stain_number]
    second_stain_list <- ihc_stain_list[-stain_number]
    second_stain_label_list <- ihc_stain_labels[-stain_number]
    second_stain_number <- 0
    for (second_stain in second_stain_list) {
      second_stain_number <- second_stain_number + 1
      second_stain_label <- second_stain_label_list[second_stain_number]
      # make a new tibble containing only tumors from slides stained for both targets
      double_stained_Tumor_Areas <- Tumor_Areas %>%
        filter(!(is.na(!!as.name(paste(stain, "total_number_nuclei_in_tumor", sep = "_"))) |
          is.na(!!as.name(paste(second_stain, "total_number_nuclei_in_tumor", sep = "_")))))

      # calculate the density of positively stained cellsper sq. mm in each tumor for stain1
      stain1_density <- double_stained_Tumor_Areas[[paste(stain, "total_positive_nuclei_in_tumor", sep = "_")]] /
        (double_stained_Tumor_Areas[["total_tumor_area"]] / (1000^2)) # convert tumor area to sq. mm

      # calculate the percent of positively stained cells in each tumor for stain2
      stain2_density <- double_stained_Tumor_Areas[[paste(second_stain, "total_positive_nuclei_in_tumor", sep = "_")]] /
        (double_stained_Tumor_Areas[["total_tumor_area"]] / (1000^2)) # convert tumor area to sq. mm

      # plot stain1_percent by stain2_percent as scatter plot. Facet by group
      plot1 <- double_stained_Tumor_Areas %>%
        ggplot(aes(
          x = stain1_density,
          y = stain2_density,
          color = group,
          alpha = 0.5
        )) +
        geom_point(alpha = 0.2) +
        scale_x_continuous() +
        scale_y_continuous() +
        scale_color_manual(
          values = group_colors,
          labels = group_labels,
          guide = "none"
        ) +
        labs(
          x = paste(first_stain_label, "+ cells / sq. mm"),
          y = paste(second_stain_label, "+ cells / sq. mm")
        ) +
        facet_wrap(~group, nrow = 1)

      # plot stain1_percent by stain2_percent as 2D density plot. Facet by group.
      plot2 <- double_stained_Tumor_Areas %>%
        ggplot(aes(
          x = stain1_density,
          y = stain2_density,
          color = group
        )) +
        geom_density_2d(contour_var = "ndensity", binwidth = 0.01) +
        scale_x_continuous() +
        scale_y_continuous() +
        scale_color_manual(
          values = group_colors,
          labels = group_labels,
          guide = "none"
        ) +
        labs(
          x = paste(first_stain_label, "+ cells / sq. mm"),
          y = paste(second_stain_label, "+ cells / sq. mm")
        ) +
        facet_wrap(~group, nrow = 1)




      plot_temp <- plot_grid(plot1, plot2, nrow = 2)
      ihc_plots_temp[[length(ihc_stain_list) * (stain_number - 1) + second_stain_number]] <- plot_temp
    }

    ihc_plots_temp[[stain_number]] <- plot_temp
  }
  plot_caption <- "Plots of proportion of cells within tumors that are positive for each IHC marker"

  # save plot_list and caption to storage variables
  ihc_plots[[ihc_plot_number]] <- ihc_plots_temp
  plot_captions[[ihc_plot_number]] <- plot_caption
}
```

```{r plot_multi_ihcstained_cell_densities, echo = FALSE, message = FALSE, warning = FALSE, results = 'asis'}
if (do_ihc_analysis) {
  # create tabset for each stain and draw plots
  if (ihc_plot_number > 0) {
    plotlistlist2tabs(ihc_plots, plot_captions, tab_names = ihc_stain_labels, tab_level = 6)
  }

  # reset storage variables
  ihc_plot_number <- 0
  ihc_plots <- list()
  plot_captions <- list()
}
```

```{r last_chunk, include = FALSE}
# DONE#
```
